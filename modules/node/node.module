<?php

/**
 * @file
 * The core that allows content to be submitted to the site. Modules and scripts may
 * programmatically submit nodes using the usual form API pattern.
 */

/**
 * Nodes changed before this time are always marked as read.
 *
 * Nodes changed after this time may be marked new, updated, or read, depending
 * on their state for the current user. Defaults to 30 days ago.
 */
define('NODE_NEW_LIMIT', time() - 30 * 24 * 60 * 60);

define('NODE_BUILD_NORMAL', 0);
define('NODE_BUILD_PREVIEW', 1);
define('NODE_BUILD_SEARCH_INDEX', 2);
define('NODE_BUILD_SEARCH_RESULT', 3);
define('NODE_BUILD_RSS', 4);
define('NODE_BUILD_PRINT', 5);

/**
 * Implementation of hook_help().
 */
function node_help($path, $arg) {
  // Remind site administrators about the {node_access} table being flagged
  // for rebuild. We don't need to issue the message on the confirm form, or
  // while the rebuild is being processed.
  if ($path != 'admin/content/node-settings/rebuild' && $path != 'batch' && strpos($path, '#') === FALSE
      && user_access('access administration pages') && node_access_needs_rebuild()) {
    if ($path == 'admin/content/node-settings') {
      $message = t('The content access permissions need to be rebuilt.');
    }
    else {
      $message = t('The content access permissions need to be rebuilt. Please visit <a href="@node_access_rebuild">this page</a>.', array('@node_access_rebuild' => url('admin/content/node-settings/rebuild')));
    }
    drupal_set_message($message, 'error');
  }

  switch ($path) {
    case 'admin/help#node':
      $output = '<p>'. t('The node module manages content on your site, and stores all posts (regardless of type) as a "node". In addition to basic publishing settings, including whether the post has been published, promoted to the site front page, or should remain present (or sticky) at the top of lists, the node module also records basic information about the author of a post. Optional revision control over edits is available. For additional functionality, the node module is often extended by other modules.') .'</p>';
      $output .= '<p>'. t('Though each post on your site is a node, each post is also of a particular <a href="@content-type">content type</a>. <a href="@content-type">Content types</a> are used to define the characteristics of a post, including the title and description of the fields displayed on its add and edit pages. Each content type may have different default settings for <em>Publishing options</em> and other workflow controls. By default, the two content types in a standard Drupal installation are <em>Page</em> and <em>Story</em>. Use the <a href="@content-type">content types page</a> to add new or edit existing content types. Additional content types also become available as you enable additional core, contributed and custom modules.', array('@content-type' => url('admin/content/types'))) .'</p>';
      $output .= '<p>'. t('The administrative <a href="@content">content page</a> allows you to review and manage your site content. The <a href="@post-settings">post settings page</a> sets certain options for the display of posts. The node module makes a number of permissions available for each content type, which may be set by role on the <a href="@permissions">permissions page</a>.', array('@content' => url('admin/content/node'), '@post-settings' => url('admin/content/node-settings'), '@permissions' => url('admin/user/permissions'))) .'</p>';
      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@node">Node module</a>.', array('@node' => 'http://drupal.org/handbook/modules/node/')) .'</p>';
      return $output;
    case 'admin/content/node':
      return ' '; // Return a non-null value so that the 'more help' link is shown.
    case 'admin/content/types':
      return '<p>'. t('Below is a list of all the content types on your site. All posts that exist on your site are instances of one of these content types.') .'</p>';
    case 'admin/content/types/add':
      return '<p>'. t('To create a new content type, enter the human-readable name, the machine-readable name, and all other relevant fields that are on this page. Once created, users of your site will be able to create posts that are instances of this content type.') .'</p>';
    case 'node/%/revisions':
      return '<p>'. t('The revisions let you track differences between multiple versions of a post.') .'</p>';
    case 'node/%/edit':
      $node = node_load($arg[1]);
      $type = node_get_types('type', $node->type);
      return (!empty($type->help) ? '<p>'. filter_xss_admin($type->help) .'</p>' : '');
  }

  if ($arg[0] == 'node' && $arg[1] == 'add' && $arg[2]) {
    $type = node_get_types('type', str_replace('-', '_', $arg[2]));
    return (!empty($type->help) ? '<p>'. filter_xss_admin($type->help) .'</p>' : '');
  }
}

/**
 * Implementation of hook_theme()
 */
function node_theme() {
  return array(
    'node' => array(
      'arguments' => array('node' => NULL, 'teaser' => FALSE, 'page' => FALSE),
      'template' => 'node',
    ),
    'node_list' => array(
      'arguments' => array('items' => NULL, 'title' => NULL),
    ),
    'node_search_admin' => array(
      'arguments' => array('form' => NULL),
    ),
    'node_filter_form' => array(
      'arguments' => array('form' => NULL),
      'file' => 'node.admin.inc',
    ),
    'node_filters' => array(
      'arguments' => array('form' => NULL),
      'file' => 'node.admin.inc',
    ),
    'node_admin_nodes' => array(
      'arguments' => array('form' => NULL),
      'file' => 'node.admin.inc',
    ),
    'node_add_list' => array(
      'arguments' => array('content' => NULL),
      'file' => 'node.pages.inc',
    ),
    'node_form' => array(
      'arguments' => array('form' => NULL),
      'file' => 'node.pages.inc',
    ),
    'node_preview' => array(
      'arguments' => array('node' => NULL),
      'file' => 'node.pages.inc',
    ),
    'node_log_message' => array(
      'arguments' => array('log' => NULL),
    ),
    'node_submitted' => array(
      'arguments' => array('node' => NULL),
    ),
  );
}

/**
 * Implementation of hook_cron().
 */
function node_cron() {
  db_query('DELETE FROM {history} WHERE timestamp < %d', NODE_NEW_LIMIT);
}

/**
 * Gather a listing of links to nodes.
 *
 * @param $result
 *   A DB result object from a query to fetch node objects. If your query
 *   joins the <code>node_comment_statistics</code> table so that the
 *   <code>comment_count</code> field is available, a title attribute will
 *   be added to show the number of comments.
 * @param $title
 *   A heading for the resulting list.
 *
 * @return
 *   An HTML list suitable as content for a block, or FALSE if no result can
 *   fetch from DB result object.
 */
function node_title_list($result, $title = NULL) {
  $items = array();
  $num_rows = FALSE;
  while ($node = db_fetch_object($result)) {
    $items[] = l($node->title, 'node/'. $node->nid, !empty($node->comment_count) ? array('attributes' => array('title' => format_plural($node->comment_count, '1 comment', '@count comments'))) : array());
    $num_rows = TRUE;
  }

  return $num_rows ? theme('node_list', $items, $title) : FALSE;
}

/**
 * Format a listing of links to nodes.
 *
 * @ingroup themeable
 */
function theme_node_list($items, $title = NULL) {
  return theme('item_list', $items, $title);
}

/**
 * Update the 'last viewed' timestamp of the specified node for current user.
 */
function node_tag_new($nid) {
  global $user;

  if ($user->uid) {
    if (node_last_viewed($nid)) {
      db_query('UPDATE {history} SET timestamp = %d WHERE uid = %d AND nid = %d', time(), $user->uid, $nid);
    }
    else {
      @db_query('INSERT INTO {history} (uid, nid, timestamp) VALUES (%d, %d, %d)', $user->uid, $nid, time());
    }
  }
}

/**
 * Retrieves the timestamp at which the current user last viewed the
 * specified node.
 */
function node_last_viewed($nid) {
  global $user;
  static $history;

  if (!isset($history[$nid])) {
    $history[$nid] = db_fetch_object(db_query("SELECT timestamp FROM {history} WHERE uid = %d AND nid = %d", $user->uid, $nid));
  }

  return (isset($history[$nid]->timestamp) ? $history[$nid]->timestamp : 0);
}

/**
 * Decide on the type of marker to be displayed for a given node.
 *
 * @param $nid
 *   Node ID whose history supplies the "last viewed" timestamp.
 * @param $timestamp
 *   Time which is compared against node's "last viewed" timestamp.
 * @return
 *   One of the MARK constants.
 */
function node_mark($nid, $timestamp) {
  global $user;
  static $cache;

  if (!$user->uid) {
    return MARK_READ;
  }
  if (!isset($cache[$nid])) {
    $cache[$nid] = node_last_viewed($nid);
  }
  if ($cache[$nid] == 0 && $timestamp > NODE_NEW_LIMIT) {
    return MARK_NEW;
  }
  elseif ($timestamp > $cache[$nid] && $timestamp > NODE_NEW_LIMIT) {
    return MARK_UPDATED;
  }
  return MARK_READ;
}

/**
 * See if the user used JS to submit a teaser.
 */
function node_teaser_js(&$form, &$form_state) {
  if (isset($form['#post']['teaser_js'])) {
    // Glue the teaser to the body.
    if (trim($form_state['values']['teaser_js'])) {
      // Space the teaser from the body
      $body = trim($form_state['values']['teaser_js']) ."\r\n<!--break-->\r\n". trim($form_state['values']['body']);
    }
    else {
      // Empty teaser, no spaces.
      $body = '<!--break-->'. $form_state['values']['body'];
    }
    // Pass updated body value on to preview/submit form processing.
    form_set_value($form['body'], $body, $form_state);
    // Pass updated body value back onto form for those cases
    // in which the form is redisplayed.
    $form['body']['#value'] = $body;
  }
  return $form;
}

/**
 * Ensure value of "teaser_include" checkbox is consistent with other form data.
 *
 * This handles two situations in which an unchecked checkbox is rejected:
 *
 *   1. The user defines a teaser (summary) but it is empty;
 *   2. The user does not define a teaser (summary) (in this case an
 *      unchecked checkbox would cause the body to be empty, or missing
 *      the auto-generated teaser).
 *
 * If JavaScript is active then it is used to force the checkbox to be
 * checked when hidden, and so the second case will not arise.
 *
 * In either case a warning message is output.
 */
function node_teaser_include_verify(&$form, &$form_state) {
  $message = '';

  // $form['#post'] is set only when the form is built for preview/submit.
  if (isset($form['#post']['body']) && isset($form_state['values']['teaser_include']) && !$form_state['values']['teaser_include']) {
    // "teaser_include" checkbox is present and unchecked.
    if (strpos($form_state['values']['body'], '<!--break-->') === 0) {
      // Teaser is empty string.
      $message = t('You specified that the summary should not be shown when this post is displayed in full view. This setting is ignored when the summary is empty.');
    }
    elseif (strpos($form_state['values']['body'], '<!--break-->') === FALSE) {
      // Teaser delimiter is not present in the body.
      $message = t('You specified that the summary should not be shown when this post is displayed in full view. This setting has been ignored since you have not defined a summary for the post. (To define a summary, insert the delimiter "&lt;!--break--&gt;" (without the quotes) in the Body of the post to indicate the end of the summary and the start of the main content.)');
    }

    if (!empty($message)) {
      drupal_set_message($message, 'warning');
      // Pass new checkbox value on to preview/submit form processing.
      form_set_value($form['teaser_include'], 1, $form_state);
      // Pass new checkbox value back onto form for those cases
      // in which form is redisplayed.
      $form['teaser_include']['#value'] = 1;
    }
  }

  return $form;
}

/**
 * Generate a teaser for a node body.
 *
 * If the end of the teaser is not indicated using the <!--break--> delimiter
 * then we generate the teaser automatically, trying to end it at a sensible
 * place such as the end of a paragraph, a line break, or the end of a
 * sentence (in that order of preference).
 *
 * @param $body
 *   The content for which a teaser will be generated.
 * @param $format
 *   The format of the content. If the content contains PHP code, we do not
 *   split it up to prevent parse errors. If the line break filter is present
 *   then we treat newlines embedded in $body as line breaks.
 * @param $size
 *   The desired character length of the teaser. If omitted, the default
 *   value will be used. Ignored if the special delimiter is present
 *   in $body.
 * @return
 *   The generated teaser.
 */
function node_teaser($body, $format = NULL, $size = NULL) {

  if (!isset($size)) {
    $size = variable_get('teaser_length', 600);
  }

  // Find where the delimiter is in the body
  $delimiter = strpos($body, '<!--break-->');

  // If the size is zero, and there is no delimiter, the entire body is the teaser.
  if ($size == 0 && $delimiter === FALSE) {
    return $body;
  }

  // If a valid delimiter has been specified, use it to chop off the teaser.
  if ($delimiter !== FALSE) {
    return substr($body, 0, $delimiter);
  }

  // We check for the presence of the PHP evaluator filter in the current
  // format. If the body contains PHP code, we do not split it up to prevent
  // parse errors.
  if (isset($format)) {
    $filters = filter_list_format($format);
    if (isset($filters['php/0']) && strpos($body, '<?') !== FALSE) {
      return $body;
    }
  }

  // If we have a short body, the entire body is the teaser.
  if (drupal_strlen($body) <= $size) {
    return $body;
  }

  // If the delimiter has not been specified, try to split at paragraph or
  // sentence boundaries.

  // The teaser may not be longer than maximum length specified. Initial slice.
  $teaser = truncate_utf8($body, $size);

  // Store the actual length of the UTF8 string -- which might not be the same
  // as $size.
  $max_rpos = strlen($teaser);

  // How much to cut off the end of the teaser so that it doesn't end in the
  // middle of a paragraph, sentence, or word.
  // Initialize it to maximum in order to find the minimum.
  $min_rpos = $max_rpos;

  // Store the reverse of the teaser.  We use strpos on the reversed needle and
  // haystack for speed and convenience.
  $reversed = strrev($teaser);

  // Build an array of arrays of break points grouped by preference.
  $break_points = array();

  // A paragraph near the end of sliced teaser is most preferable.
  $break_points[] = array('</p>' => 0);

  // If no complete paragraph then treat line breaks as paragraphs.
  $line_breaks = array('<br />' => 6, '<br>' => 4);
  // Newline only indicates a line break if line break converter
  // filter is present.
  if (isset($filters['filter/1'])) {
    $line_breaks["\n"] = 1;
  }
  $break_points[] = $line_breaks;

  // If the first paragraph is too long, split at the end of a sentence.
  $break_points[] = array('. ' => 1, '! ' => 1, '? ' => 1, '。' => 0, '؟ ' => 1);

  // Iterate over the groups of break points until a break point is found.
  foreach ($break_points as $points) {
    // Look for each break point, starting at the end of the teaser.
    foreach ($points as $point => $offset) {
      // The teaser is already reversed, but the break point isn't.
      $rpos = strpos($reversed, strrev($point));
      if ($rpos !== FALSE) {
        $min_rpos = min($rpos + $offset, $min_rpos);
      }
    }

    // If a break point was found in this group, slice and return the teaser.
    if ($min_rpos !== $max_rpos) {
      // Don't slice with length 0.  Length must be <0 to slice from RHS.
      return ($min_rpos === 0) ? $teaser : substr($teaser, 0, 0 - $min_rpos);
    }
  }

  // If a break point was not found, still return a teaser.
  return $teaser;
}

/**
 * Builds a list of available node types, and returns all or part of this list.
 *
 * @param $op
 *   The format in which to return the list: 'type', 'types', 'module', 'name',
 *   or 'names'. See return value section below for details.
 * @param $node
 *   A node object, an array representation of a node object, or a node type
 *   name string. See return value section below for details.
 * @param $reset
 *   Whether or not to reset this function's internal cache (defaults to
 *   FALSE).
 *
 * @return
 *   If $node is supplied and it doesn't correspond to a known node type,
 *   or if $op is 'type', 'name', or 'module' and $node is not given, the
 *   function returns FALSE. Otherwise, the return value depends on the
 *   value of $op:
 *   - 'types': An array of all available node type objects, keyed by machine
 *     name.
 *   - 'type': The single node type object indicated by $node.
 *   - 'names': An array of the display names of all available node types,
 *     keyed by machine name and sorted by display name.
 *   - 'name': The single node type display name indicated by $node.
 *   - 'module': The name of the node type module indicated by $node.
 */
function node_get_types($op = 'types', $node = NULL, $reset = FALSE) {
  static $_node_types, $_node_names;

  if ($reset || !isset($_node_types)) {
    list($_node_types, $_node_names) = _node_types_build();
  }

  if ($node) {
    if (is_array($node)) {
      $type = $node['type'];
    }
    elseif (is_object($node)) {
      $type = $node->type;
    }
    elseif (is_string($node)) {
      $type = $node;
    }
    if (!isset($_node_types[$type])) {
      return FALSE;
    }
  }
  switch ($op) {
    case 'types':
      return $_node_types;
    case 'type':
      return isset($_node_types[$type]) ? $_node_types[$type] : FALSE;
    case 'module':
      return isset($_node_types[$type]->module) ? $_node_types[$type]->module : FALSE;
    case 'names':
      return $_node_names;
    case 'name':
      return isset($_node_names[$type]) ? $_node_names[$type] : FALSE;
  }
}

/**
 * Resets the database cache of node types, and saves all new or non-modified
 * module-defined node types to the database.
 */
function node_types_rebuild() {
  _node_types_build();

  $node_types = node_get_types('types', NULL, TRUE);

  foreach ($node_types as $type => $info) {
    if (!empty($info->is_new)) {
      node_type_save($info);
    }
    if (!empty($info->disabled)) {
      node_type_delete($info->type);
    }
  }

  _node_types_build();
}

/**
 * Saves a node type to the database.
 *
 * @param $info
 *   The node type to save, as an object.
 *
 * @return
 *   Status flag indicating outcome of the operation.
 */
function node_type_save($info) {
  $is_existing = FALSE;
  $existing_type = !empty($info->old_type) ? $info->old_type : $info->type;
  $is_existing = db_result(db_query("SELECT COUNT(*) FROM {node_type} WHERE type = '%s'", $existing_type));
  if (!isset($info->help)) {
    $info->help = '';
  }
  if (!isset($info->min_word_count)) {
    $info->min_word_count = 0;
  }
  if (!isset($info->body_label)) {
    $info->body_label = '';
  }

  if ($is_existing) {
    db_query("UPDATE {node_type} SET type = '%s', name = '%s', module = '%s', has_title = %d, title_label = '%s', has_body = %d, body_label = '%s', description = '%s', help = '%s', min_word_count = %d, custom = %d, modified = %d, locked = %d WHERE type = '%s'", $info->type, $info->name, $info->module, $info->has_title, $info->title_label, $info->has_body, $info->body_label, $info->description, $info->help, $info->min_word_count, $info->custom, $info->modified, $info->locked, $existing_type);

    module_invoke_all('node_type', 'update', $info);
    return SAVED_UPDATED;
  }
  else {
    db_query("INSERT INTO {node_type} (type, name, module, has_title, title_label, has_body, body_label, description, help, min_word_count, custom, modified, locked, orig_type) VALUES ('%s', '%s', '%s', %d, '%s', %d, '%s', '%s', '%s', %d, %d, %d, %d, '%s')", $info->type, $info->name, $info->module, $info->has_title, $info->title_label, $info->has_body, $info->body_label, $info->description, $info->help, $info->min_word_count, $info->custom, $info->modified, $info->locked, $info->orig_type);

    module_invoke_all('node_type', 'insert', $info);
    return SAVED_NEW;
  }
}

/**
 * Deletes a node type from the database.
 *
 * @param $type
 *   The machine-readable name of the node type to be deleted.
 */
function node_type_delete($type) {
  $info = node_get_types('type', $type);
  db_query("DELETE FROM {node_type} WHERE type = '%s'", $type);
  module_invoke_all('node_type', 'delete', $info);
}

/**
 * Updates all nodes of one type to be of another type.
 *
 * @param $old_type
 *   The current node type of the nodes.
 * @param $type
 *   The new node type of the nodes.
 *
 * @return
 *   The number of nodes whose node type field was modified.
 */
function node_type_update_nodes($old_type, $type) {
  db_query("UPDATE {node} SET type = '%s' WHERE type = '%s'", $type, $old_type);
  return db_affected_rows();
}

/**
 * Builds and returns the list of available node types.
 *
 * The list of types is built by querying hook_node_info() in all modules, and
 * by comparing this information with the node types in the {node_type} table.
 *
 */
function _node_types_build() {
  $_node_types = array();
  $_node_names = array();

  $info_array = module_invoke_all('node_info');
  foreach ($info_array as $type => $info) {
    $info['type'] = $type;
    $_node_types[$type] = (object) _node_type_set_defaults($info);
    $_node_names[$type] = $info['name'];
  }

  $type_result = db_query(db_rewrite_sql('SELECT nt.type, nt.* FROM {node_type} nt ORDER BY nt.type ASC', 'nt', 'type'));
  while ($type_object = db_fetch_object($type_result)) {
    // Check for node types from disabled modules and mark their types for removal.
    // Types defined by the node module in the database (rather than by a separate
    // module using hook_node_info) have a module value of 'node'.
    if ($type_object->module != 'node' && empty($info_array[$type_object->type])) {
      $type_object->disabled = TRUE;
    }
    if (!isset($_node_types[$type_object->type]) || $type_object->modified) {
      $_node_types[$type_object->type] = $type_object;
      $_node_names[$type_object->type] = $type_object->name;

      if ($type_object->type != $type_object->orig_type) {
        unset($_node_types[$type_object->orig_type]);
        unset($_node_names[$type_object->orig_type]);
      }
    }
  }

  asort($_node_names);

  return array($_node_types, $_node_names);
}

/**
 * Set default values for a node type defined through hook_node_info().
 */
function _node_type_set_defaults($info) {
  if (!isset($info['has_title'])) {
    $info['has_title'] = TRUE;
  }
  if ($info['has_title'] && !isset($info['title_label'])) {
    $info['title_label'] = t('Title');
  }

  if (!isset($info['has_body'])) {
    $info['has_body'] = TRUE;
  }
  if ($info['has_body'] && !isset($info['body_label'])) {
    $info['body_label'] = t('Body');
  }

  if (!isset($info['help'])) {
    $info['help'] = '';
  }
  if (!isset($info['min_word_count'])) {
    $info['min_word_count'] = 0;
  }
  if (!isset($info['custom'])) {
    $info['custom'] = FALSE;
  }
  if (!isset($info['modified'])) {
    $info['modified'] = FALSE;
  }
  if (!isset($info['locked'])) {
    $info['locked'] = TRUE;
  }

  $info['orig_type'] = $info['type'];
  $info['is_new'] = TRUE;

  return $info;
}

/**
 * Determine whether a node hook exists.
 *
 * @param &$node
 *   Either a node object, node array, or a string containing the node type.
 * @param $hook
 *   A string containing the name of the hook.
 * @return
 *   TRUE iff the $hook exists in the node type of $node.
 */
function node_hook(&$node, $hook) {
  $module = node_get_types('module', $node);
  if ($module == 'node') {
    $module = 'node_content'; // Avoid function name collisions.
  }
  return module_hook($module, $hook);
}

/**
 * Invoke a node hook.
 *
 * @param &$node
 *   Either a node object, node array, or a string containing the node type.
 * @param $hook
 *   A string containing the name of the hook.
 * @param $a2, $a3, $a4
 *   Arguments to pass on to the hook, after the $node argument.
 * @return
 *   The returned value of the invoked hook.
 */
function node_invoke(&$node, $hook, $a2 = NULL, $a3 = NULL, $a4 = NULL) {
  if (node_hook($node, $hook)) {
    $module = node_get_types('module', $node);
    if ($module == 'node') {
      $module = 'node_content'; // Avoid function name collisions.
    }
    $function = $module .'_'. $hook;
    return ($function($node, $a2, $a3, $a4));
  }
}

/**
 * Invoke a hook_nodeapi() operation in all modules.
 *
 * @param &$node
 *   A node object.
 * @param $op
 *   A string containing the name of the nodeapi operation.
 * @param $a3, $a4
 *   Arguments to pass on to the hook, after the $node and $op arguments.
 * @return
 *   The returned value of the invoked hooks.
 */
function node_invoke_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  $return = array();
  foreach (module_implements('nodeapi') as $name) {
    $function = $name .'_nodeapi';
    $result = $function($node, $op, $a3, $a4);
    if (isset($result) && is_array($result)) {
      $return = array_merge($return, $result);
    }
    else if (isset($result)) {
      $return[] = $result;
    }
  }
  return $return;
}

/**
 * Load a node object from the database.
 *
 * @param $param
 *   Either the nid of the node or an array of conditions to match against in the database query
 * @param $revision
 *   Which numbered revision to load. Defaults to the current version.
 * @param $reset
 *   Whether to reset the internal node_load cache.
 *
 * @return
 *   A fully-populated node object.
 */
function node_load($param = array(), $revision = NULL, $reset = NULL) {
  static $nodes = array();

  if ($reset) {
    $nodes = array();
  }

  $cachable = ($revision == NULL);
  $arguments = array();
  if (is_numeric($param)) {
    if ($cachable) {
      // Is the node statically cached?
      if (isset($nodes[$param])) {
        return is_object($nodes[$param]) ? drupal_clone($nodes[$param]) : $nodes[$param];
      }
    }
    $cond = 'n.nid = %d';
    $arguments[] = $param;
  }
  elseif (is_array($param)) {
    // Turn the conditions into a query.
    foreach ($param as $key => $value) {
      $cond[] = 'n.'. db_escape_table($key) ." = '%s'";
      $arguments[] = $value;
    }
    $cond = implode(' AND ', $cond);
  }
  else {
    return FALSE;
  }

  // Retrieve a field list based on the site's schema.
  $fields = drupal_schema_fields_sql('node', 'n');
  $fields = array_merge($fields, drupal_schema_fields_sql('node_revisions', 'r'));
  $fields = array_merge($fields, array('u.name', 'u.picture', 'u.data'));
  // Remove fields not needed in the query: n.vid and r.nid are redundant,
  // n.title is unnecessary because the node title comes from the
  // node_revisions table.  We'll keep r.vid, r.title, and n.nid.
  $fields = array_diff($fields, array('n.vid', 'n.title', 'r.nid'));
  $fields = implode(', ', $fields);
  // Rename timestamp field for clarity.
  $fields = str_replace('r.timestamp', 'r.timestamp AS revision_timestamp', $fields);
  // Change name of revision uid so it doesn't conflict with n.uid.
  $fields = str_replace('r.uid', 'r.uid AS revision_uid', $fields);

  // Retrieve the node.
  // No db_rewrite_sql is applied so as to get complete indexing for search.
  if ($revision) {
    array_unshift($arguments, $revision);
    $node = db_fetch_object(db_query_slave('SELECT '. $fields .' FROM {node} n INNER JOIN {users} u ON u.uid = n.uid INNER JOIN {node_revisions} r ON r.nid = n.nid AND r.vid = %d WHERE '. $cond, $arguments));
  }
  else {
    $node = db_fetch_object(db_query_slave('SELECT '. $fields .' FROM {node} n INNER JOIN {users} u ON u.uid = n.uid INNER JOIN {node_revisions} r ON r.vid = n.vid WHERE '. $cond, $arguments));
  }

  if ($node && $node->nid) {
    // Call the node specific callback (if any) and piggy-back the
    // results to the node or overwrite some values.
    if ($extra = node_invoke($node, 'load')) {
      foreach ($extra as $key => $value) {
        $node->$key = $value;
      }
    }

    if ($extra = node_invoke_nodeapi($node, 'load')) {
      foreach ($extra as $key => $value) {
        $node->$key = $value;
      }
    }
    if ($cachable) {
      $nodes[$node->nid] = is_object($node) ? drupal_clone($node) : $node;
    }
  }

  return $node;
}

/**
 * Perform validation checks on the given node.
 */
function node_validate($node, $form = array()) {
  // Convert the node to an object, if necessary.
  $node = (object)$node;
  $type = node_get_types('type', $node);

  // Make sure the body has the minimum number of words.
  // TODO : use a better word counting algorithm that will work in other languages
  if (!empty($type->min_word_count) && isset($node->body) && count(explode(' ', $node->body)) < $type->min_word_count) {
    form_set_error('body', t('The @body_label of your @type is too short. You need at least %words words.', array('@body_label' => $type->body_label, '@type' => $type->name, '%words' => $type->min_word_count)));
  }

  if (isset($node->nid) && (node_last_changed($node->nid) > $node->changed)) {
    form_set_error('changed', t('This content has been modified by another user, changes cannot be saved.'));
  }

  if (user_access('administer nodes')) {
    // Validate the "authored by" field.
    if (!empty($node->name) && !($account = user_load(array('name' => $node->name)))) {
      // The use of empty() is mandatory in the context of usernames
      // as the empty string denotes the anonymous user. In case we
      // are dealing with an anonymous user we set the user ID to 0.
      form_set_error('name', t('The username %name does not exist.', array('%name' => $node->name)));
    }

    // Validate the "authored on" field. As of PHP 5.1.0, strtotime returns FALSE instead of -1 upon failure.
    if (!empty($node->date) && strtotime($node->date) <= 0) {
      form_set_error('date', t('You have to specify a valid date.'));
    }
  }

  // Do node-type-specific validation checks.
  node_invoke($node, 'validate', $form);
  node_invoke_nodeapi($node, 'validate', $form);
}

/**
 * Prepares a node for saving by populating teaser, author, and creation date.
 *
 * @param object|array $node
 *   A node object or array.
 *
 * @return
 *   A validated node object with a populated teaser, author, and creation date.
 */
function node_submit($node) {
  global $user;

  // Convert the node to an object, if necessary.
  $node = (object)$node;

  // Generate the teaser, but only if it hasn't been set (e.g. by a
  // module-provided 'teaser' form item).
  if (!isset($node->teaser)) {
    if (isset($node->body)) {
      $node->teaser = node_teaser($node->body, isset($node->format) ? $node->format : NULL);
      // Chop off the teaser from the body if needed. The teaser_include
      // property might not be set (eg. in Blog API postings), so only act on
      // it, if it was set with a given value.
      if (isset($node->teaser_include) && !$node->teaser_include && $node->teaser == substr($node->body, 0, strlen($node->teaser))) {
        $node->body = substr($node->body, strlen($node->teaser));
      }
    }
    else {
      $node->teaser = '';
      $node->format = 0;
    }
  }

  if (user_access('administer nodes')) {
    // Populate the "authored by" field.
    if ($account = user_load(array('name' => $node->name))) {
      $node->uid = $account->uid;
    }
    else {
      $node->uid = 0;
    }
  }
  $node->created = !empty($node->date) ? strtotime($node->date) : time();
  $node->validated = TRUE;

  return $node;
}

/**
 * Save a node object into the database.
 */
function node_save(&$node) {
  // Let modules modify the node before it is saved to the database.
  node_invoke_nodeapi($node, 'presave');
  global $user;

  // Insert a new node.
  $node->is_new = empty($node->nid);

  if ($node->is_new || !empty($node->revision)) {
    // When inserting a node, $node->log must be set because
    // {node_revisions}.log does not (and cannot) have a default
    // value.  If the user does not have permission to create
    // revisions, however, the form will not contain an element for
    // log so $node->log will be unset at this point.
    if (!isset($node->log)) {
      $node->log = '';
    }
  }
  elseif (empty($node->log)) {
    // When updating a node, however, avoid clobbering an existing
    // log entry with an empty one.
    unset($node->log);
  }

  // For the same reasons, make sure we have $node->teaser and
  // $node->body set.
  if (!isset($node->teaser)) {
    $node->teaser = '';
  }
  if (!isset($node->body)) {
    $node->body = '';
  }

  // Save the old revision if needed.
  if (!$node->is_new && !empty($node->revision) && $node->vid) {
    $node->old_vid = $node->vid;
  }

  $time = time();
  if (empty($node->created)) {
    $node->created = $time;
  }
  // The changed timestamp is always updated for bookkeeping purposes (revisions, searching, ...)
  $node->changed = $time;

  $node->timestamp = $time;
  $node->format = isset($node->format) ? $node->format : FILTER_FORMAT_DEFAULT;

  // Generate the node table query and the node_revisions table query.
  if ($node->is_new) {
    _node_save_revision($node, $user->uid);
    drupal_write_record('node', $node);
    db_query('UPDATE {node_revisions} SET nid = %d WHERE vid = %d', $node->nid, $node->vid);
    $op = 'insert';
  }
  else {
    drupal_write_record('node', $node, 'nid');
    if (!empty($node->revision)) {
      _node_save_revision($node, $user->uid);
      db_query('UPDATE {node} SET vid = %d WHERE nid = %d', $node->vid, $node->nid);
    }
    else {
      _node_save_revision($node, $user->uid, 'vid');
    }
    $op = 'update';
  }

  // Call the node specific callback (if any).
  node_invoke($node, $op);
  node_invoke_nodeapi($node, $op);

  // Update the node access table for this node.
  node_access_acquire_grants($node);

  // Clear the page and block caches.
  cache_clear_all();

  // Ignore slave server temporarily to give time for the
  // saved node to be propagated to the slave.
  db_ignore_slave();
}

/**
 * Helper function to save a revision with the uid of the current user.
 *
 * Node is taken by reference, becuse drupal_write_record() updates the
 * $node with the revision id, and we need to pass that back to the caller.
 */
function _node_save_revision(&$node, $uid, $update = NULL) {
  $temp_uid = $node->uid;
  $node->uid = $uid;
  if (isset($update)) {
    drupal_write_record('node_revisions', $node, $update);
  }
  else {
    drupal_write_record('node_revisions', $node);
  }
  $node->uid = $temp_uid;
}

/**
 * Delete a node.
 */
function node_delete($nid) {

  // Clear the cache before the load, so if multiple nodes are deleted, the
  // memory will not fill up with nodes (possibly) already removed.
  $node = node_load($nid, NULL, TRUE);

  if (node_access('delete', $node)) {
    db_query('DELETE FROM {node} WHERE nid = %d', $node->nid);
    db_query('DELETE FROM {node_revisions} WHERE nid = %d', $node->nid);
    db_query('DELETE FROM {node_access} WHERE nid = %d', $node->nid);

    // Call the node-specific callback (if any):
    node_invoke($node, 'delete');
    node_invoke_nodeapi($node, 'delete');

    // Clear the page and block caches.
    cache_clear_all();

    // Remove this node from the search index if needed.
    if (function_exists('search_wipe')) {
      search_wipe($node->nid, 'node');
    }
    watchdog('content', '@type: deleted %title.', array('@type' => $node->type, '%title' => $node->title));
    drupal_set_message(t('@type %title has been deleted.', array('@type' => node_get_types('name', $node), '%title' => $node->title)));
  }
}

/**
 * Generate a display of the given node.
 *
 * @param $node
 *   A node array or node object.
 * @param $teaser
 *   Whether to display the teaser only or the full form.
 * @param $page
 *   Whether the node is being displayed by itself as a page.
 * @param $links
 *   Whether or not to display node links. Links are omitted for node previews.
 *
 * @return
 *   An HTML representation of the themed node.
 */
function node_view($node, $teaser = FALSE, $page = FALSE, $links = TRUE) {
  $node = (object)$node;

  $node = node_build_content($node, $teaser, $page);

  if ($links) {
    $node->links = module_invoke_all('link', 'node', $node, $teaser);
    drupal_alter('link', $node->links, $node);
  }

  // Set the proper node part, then unset unused $node part so that a bad
  // theme can not open a security hole.
  $content = drupal_render($node->content);
  if ($teaser) {
    $node->teaser = $content;
    unset($node->body);
  }
  else {
    $node->body = $content;
    unset($node->teaser);
  }

  // Allow modules to modify the fully-built node.
  node_invoke_nodeapi($node, 'alter', $teaser, $page);

  return theme('node', $node, $teaser, $page);
}

/**
 * Apply filters and build the node's standard elements.
 */
function node_prepare($node, $teaser = FALSE) {
  // First we'll overwrite the existing node teaser and body with
  // the filtered copies! Then, we'll stick those into the content
  // array and set the read more flag if appropriate.
  $node->readmore = $node->teaser != $node->body;

  if ($teaser == FALSE) {
    $node->body = check_markup($node->body, $node->format, FALSE);
  }
  else {
    $node->teaser = check_markup($node->teaser, $node->format, FALSE);
  }

  $node->content['body'] = array(
    '#value' => $teaser ? $node->teaser : $node->body,
    '#weight' => 0,
  );

  return $node;
}

/**
 * Builds a structured array representing the node's content.
 *
 * @param $node
 *   A node object.
 * @param $teaser
 *   Whether to display the teaser only, as on the main page.
 * @param $page
 *   Whether the node is being displayed by itself as a page.
 *
 * @return
 *   A node object with its content property set to a structured array
 *   containing the individual elements of the node's body.
 */
function node_build_content($node, $teaser = FALSE, $page = FALSE) {

  // The build mode identifies the target for which the node is built.
  if (!isset($node->build_mode)) {
    $node->build_mode = NODE_BUILD_NORMAL;
  }

  // Remove the delimiter (if any) that separates the teaser from the body.
  $node->body = isset($node->body) ? str_replace('<!--break-->', '', $node->body) : '';

  // The 'view' hook can be implemented to overwrite the default function
  // to display nodes.
  if (node_hook($node, 'view')) {
    $node = node_invoke($node, 'view', $teaser, $page);
  }
  else {
    $node = node_prepare($node, $teaser);
  }

  // Allow modules to make their own additions to the node.
  node_invoke_nodeapi($node, 'view', $teaser, $page);

  return $node;
}

/**
 * Generate a page displaying a single node, along with its comments.
 */
function node_show($node, $cid, $message = FALSE) {
  if ($message) {
    drupal_set_title(t('Revision of %title from %date', array('%title' => $node->title, '%date' => format_date($node->revision_timestamp))));
  }
  $output = node_view($node, FALSE, TRUE);

  if (function_exists('comment_render') && $node->comment) {
    $output .= comment_render($node, $cid);
  }

  // Update the history table, stating that this user viewed this node.
  node_tag_new($node->nid);

  return $output;
}

/**
 * Theme a log message.
 *
 * @ingroup themeable
 */
function theme_node_log_message($log) {
  return '<div class="log"><div class="title">'. t('Log') .':</div>'. $log .'</div>';
}

/**
 * Implementation of hook_perm().
 */
function node_perm() {
  $perms = array('administer content types', 'administer nodes', 'access content', 'view revisions', 'revert revisions', 'delete revisions');

  foreach (node_get_types() as $type) {
    if ($type->module == 'node') {
      $name = check_plain($type->type);
      $perms[] = 'create '. $name .' content';
      $perms[] = 'delete own '. $name .' content';
      $perms[] = 'delete any '. $name .' content';
      $perms[] = 'edit own '. $name .' content';
      $perms[] = 'edit any '. $name .' content';
    }
  }

  return $perms;
}

/**
 * Implementation of hook_search().
 */
function node_search($op = 'search', $keys = NULL) {
  switch ($op) {
    case 'name':
      return t('Content');

    case 'reset':
      db_query("UPDATE {search_dataset} SET reindex = %d WHERE type = 'node'", time());
      return;

    case 'status':
      $total = db_result(db_query('SELECT COUNT(*) FROM {node} WHERE status = 1'));
      $remaining = db_result(db_query("SELECT COUNT(*) FROM {node} n LEFT JOIN {search_dataset} d ON d.type = 'node' AND d.sid = n.nid WHERE n.status = 1 AND (d.sid IS NULL OR d.reindex <> 0)"));
      return array('remaining' => $remaining, 'total' => $total);

    case 'admin':
      $form = array();
      // Output form for defining rank factor weights.
      $form['content_ranking'] = array(
        '#type' => 'fieldset',
        '#title' => t('Content ranking'),
      );
      $form['content_ranking']['#theme'] = 'node_search_admin';
      $form['content_ranking']['info'] = array(
        '#value' => '<em>'. t('The following numbers control which properties the content search should favor when ordering the results. Higher numbers mean more influence, zero means the property is ignored. Changing these numbers does not require the search index to be rebuilt. Changes take effect immediately.') .'</em>'
      );

      $ranking = array('node_rank_relevance' => t('Keyword relevance'),
                       'node_rank_recent' => t('Recently posted'));
      if (module_exists('comment')) {
        $ranking['node_rank_comments'] = t('Number of comments');
      }
      if (module_exists('statistics') && variable_get('statistics_count_content_views', 0)) {
        $ranking['node_rank_views'] = t('Number of views');
      }

      // Note: reversed to reflect that higher number = higher ranking.
      $options = drupal_map_assoc(range(0, 10));
      foreach ($ranking as $var => $title) {
        $form['content_ranking']['factors'][$var] = array(
          '#title' => $title,
          '#type' => 'select',
          '#options' => $options,
          '#default_value' => variable_get($var, 5),
        );
      }
      return $form;

    case 'search':
      // Build matching conditions
      list($join1, $where1) = _db_rewrite_sql();
      $arguments1 = array();
      $conditions1 = 'n.status = 1';

      if ($type = search_query_extract($keys, 'type')) {
        $types = array();
        foreach (explode(',', $type) as $t) {
          $types[] = "n.type = '%s'";
          $arguments1[] = $t;
        }
        $conditions1 .= ' AND ('. implode(' OR ', $types) .')';
        $keys = search_query_insert($keys, 'type');
      }

      if ($category = search_query_extract($keys, 'category')) {
        $categories = array();
        foreach (explode(',', $category) as $c) {
          $categories[] = "tn.tid = %d";
          $arguments1[] = $c;
        }
        $conditions1 .= ' AND ('. implode(' OR ', $categories) .')';
        $join1 .= ' INNER JOIN {term_node} tn ON n.vid = tn.vid';
        $keys = search_query_insert($keys, 'category');
      }

      // Build ranking expression (we try to map each parameter to a
      // uniform distribution in the range 0..1).
      $ranking = array();
      $arguments2 = array();
      $join2 = '';
      // Used to avoid joining on node_comment_statistics twice
      $stats_join = FALSE;
      $total = 0;
      if ($weight = (int)variable_get('node_rank_relevance', 5)) {
        // Average relevance values hover around 0.15
        $ranking[] = '%d * i.relevance';
        $arguments2[] = $weight;
        $total += $weight;
      }
      if ($weight = (int)variable_get('node_rank_recent', 5)) {
        // Exponential decay with half-life of 6 months, starting at last indexed node
        // c.last_comment_timestamp may be NULL. Since both MAX(anynumber, NULL) and
        // GREATEST(anynumber, NULL) return NULL, we use COALESCE(MAX(c.last_comment_timestamp), 0)
        // to prevent it from being NULL.
        $ranking[] = '%d * POW(2, (GREATEST(MAX(n.created), MAX(n.changed), COALESCE(MAX(c.last_comment_timestamp), 0)) - %d) * 6.43e-8)';
        $arguments2[] = $weight;
        $arguments2[] = (int)variable_get('node_cron_last', 0);
        $join2 .= ' LEFT JOIN {node_comment_statistics} c ON c.nid = i.sid';
        $stats_join = TRUE;
        $total += $weight;
      }
      if (module_exists('comment') && $weight = (int)variable_get('node_rank_comments', 5)) {
        // Inverse law that maps the highest reply count on the site to 1 and 0 to 0.
        $scale = variable_get('node_cron_comments_scale', 0.0);
        $ranking[] = '%d * (2.0 - 2.0 / (1.0 + MAX(c.comment_count) * %f))';
        $arguments2[] = $weight;
        $arguments2[] = $scale;
        if (!$stats_join) {
          $join2 .= ' LEFT JOIN {node_comment_statistics} c ON c.nid = i.sid';
        }
        $total += $weight;
      }
      if (module_exists('statistics') && variable_get('statistics_count_content_views', 0) &&
          $weight = (int)variable_get('node_rank_views', 5)) {
        // Inverse law that maps the highest view count on the site to 1 and 0 to 0.
        $scale = variable_get('node_cron_views_scale', 0.0);
        $ranking[] = '%d * (2.0 - 2.0 / (1.0 + MAX(nc.totalcount) * %f))';
        $arguments2[] = $weight;
        $arguments2[] = $scale;
        $join2 .= ' LEFT JOIN {node_counter} nc ON nc.nid = i.sid';
        $total += $weight;
      }
      
      // When all search factors are disabled (ie they have a weight of zero), 
      // the default score is based only on keyword relevance and there is no need to 
      // adjust the score of each item. 
      if ($total == 0) {
        $select2 = 'i.relevance AS score';
        $total = 1;
      }
      else {
        $select2 = implode(' + ', $ranking) . ' AS score';
      }
      
      // Do search.
      $find = do_search($keys, 'node', 'INNER JOIN {node} n ON n.nid = i.sid '. $join1, $conditions1 . (empty($where1) ? '' : ' AND '. $where1), $arguments1, $select2, $join2, $arguments2);

      // Load results.
      $results = array();
      foreach ($find as $item) {
        // Build the node body.
        $node = node_load($item->sid);
        $node->build_mode = NODE_BUILD_SEARCH_RESULT;
        $node = node_build_content($node, FALSE, FALSE);
        $node->body = drupal_render($node->content);

        // Fetch comments for snippet.
        if (module_exists('comment')) {
          $node->body .= comment_nodeapi($node, 'update index');
        }
        // Fetch terms for snippet.
        if (module_exists('taxonomy')) {
          $node->body .= taxonomy_nodeapi($node, 'update index');
        }

        $extra = node_invoke_nodeapi($node, 'search result');
        $results[] = array(
          'link' => url('node/'. $item->sid, array('absolute' => TRUE)),
          'type' => check_plain(node_get_types('name', $node)),
          'title' => $node->title,
          'user' => theme('username', $node),
          'date' => $node->changed,
          'node' => $node,
          'extra' => $extra,
          'score' => $item->score / $total,
          'snippet' => search_excerpt($keys, $node->body),
        );
      }
      return $results;
  }
}

/**
 * Implementation of hook_user().
 */
function node_user($op, &$edit, &$user) {
  if ($op == 'delete') {
    db_query('UPDATE {node} SET uid = 0 WHERE uid = %d', $user->uid);
    db_query('UPDATE {node_revisions} SET uid = 0 WHERE uid = %d', $user->uid);
  }
}

/**
 * Theme the content ranking part of the search settings admin page.
 *
 * @ingroup themeable
 */
function theme_node_search_admin($form) {
  $output = drupal_render($form['info']);

  $header = array(t('Factor'), t('Weight'));
  foreach (element_children($form['factors']) as $key) {
    $row = array();
    $row[] = $form['factors'][$key]['#title'];
    unset($form['factors'][$key]['#title']);
    $row[] = drupal_render($form['factors'][$key]);
    $rows[] = $row;
  }
  $output .= theme('table', $header, $rows);

  $output .= drupal_render($form);
  return $output;
}

/**
 * Retrieve the comment mode for the given node ID (none, read, or read/write).
 */
function node_comment_mode($nid) {
  static $comment_mode;
  if (!isset($comment_mode[$nid])) {
    $comment_mode[$nid] = db_result(db_query('SELECT comment FROM {node} WHERE nid = %d', $nid));
  }
  return $comment_mode[$nid];
}

/**
 * Implementation of hook_link().
 */
function node_link($type, $node = NULL, $teaser = FALSE) {
  $links = array();

  if ($type == 'node') {
    if ($teaser == 1 && $node->teaser && !empty($node->readmore)) {
      $links['node_read_more'] = array(
        'title' => t('Read more'),
        'href' => "node/$node->nid",
        // The title attribute gets escaped when the links are processed, so
        // there is no need to escape here.
        'attributes' => array('title' => t('Read the rest of !title.', array('!title' => $node->title)))
      );
    }
  }

  return $links;
}

function _node_revision_access($node, $op = 'view') {
  static $access = array();
  if (!isset($access[$node->vid])) {
    $node_current_revision = node_load($node->nid);
    $is_current_revision = $node_current_revision->vid == $node->vid;
    // There should be at least two revisions. If the vid of the given node
    // and the vid of the current revision differs, then we already have two
    // different revisions so there is no need for a separate database check.
    // Also, if you try to revert to or delete the current revision, that's
    // not good.
    if ($is_current_revision && (db_result(db_query('SELECT COUNT(vid) FROM {node_revisions} WHERE nid = %d', $node->nid)) == 1 || $op == 'update' || $op == 'delete')) {
      $access[$node->vid] = FALSE;
    }
    elseif (user_access('administer nodes')) {
      $access[$node->vid] = TRUE;
    }
    else {
      $map = array('view' => 'view revisions', 'update' => 'revert revisions', 'delete' => 'delete revisions');
      // First check the user permission, second check the access to the
      // current revision and finally, if the node passed in is not the current
      // revision then access to that, too.
      $access[$node->vid] = isset($map[$op]) && user_access($map[$op]) && node_access($op, $node_current_revision) && ($is_current_revision || node_access($op, $node));
    }
  }
  return $access[$node->vid];
}

function _node_add_access() {
  $types = node_get_types();
  foreach ($types as $type) {
    if (node_hook($type->type, 'form') && node_access('create', $type->type)) {
      return TRUE;
    }
  }
  return FALSE;
}

/**
 * Implementation of hook_menu().
 */
function node_menu() {
  $items['admin/content/node'] = array(
    'title' => 'Content',
    'description' => "View, edit, and delete your site's content.",
    'page callback' => 'drupal_get_form',
    'page arguments' => array('node_admin_content'),
    'access arguments' => array('administer nodes'),
    'file' => 'node.admin.inc',
  );

  $items['admin/content/node/overview'] = array(
    'title' => 'List',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );

  $items['admin/content/node-settings'] = array(
    'title' => 'Post settings',
    'description' => 'Control posting behavior, such as teaser length, requiring previews before posting, and the number of posts on the front page.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('node_configure'),
    'access arguments' => array('administer nodes'),
    'file' => 'node.admin.inc',
  );
  $items['admin/content/node-settings/rebuild'] = array(
    'title' => 'Rebuild permissions',
    'page arguments' => array('node_configure_rebuild_confirm'),
    'file' => 'node.admin.inc',
    // Any user than can potentially trigger a node_acess_needs_rebuild(TRUE)
    // has to be allowed access to the 'node access rebuild' confirm form.
    'access arguments' => array('access administration pages'),
    'type' => MENU_CALLBACK,
  );

  $items['admin/content/types'] = array(
    'title' => 'Content types',
    'description' => 'Manage posts by content type, including default status, front page promotion, etc.',
    'page callback' => 'node_overview_types',
    'access arguments' => array('administer content types'),
    'file' => 'content_types.inc',
  );
  $items['admin/content/types/list'] = array(
    'title' => 'List',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items['admin/content/types/add'] = array(
    'title' => 'Add content type',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('node_type_form'),
    'access arguments' => array('administer content types'),
    'file' => 'content_types.inc',
    'type' => MENU_LOCAL_TASK,
  );
  $items['node'] = array(
    'title' => 'Content',
    'page callback' => 'node_page_default',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  $items['node/add'] = array(
    'title' => 'Create content',
    'page callback' => 'node_add_page',
    'access callback' => '_node_add_access',
    'weight' => 1,
    'file' => 'node.pages.inc',
  );
  $items['rss.xml'] = array(
    'title' => 'RSS feed',
    'page callback' => 'node_feed',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  foreach (node_get_types('types', NULL, TRUE) as $type) {
    $type_url_str = str_replace('_', '-', $type->type);
    $items['node/add/'. $type_url_str] = array(
      'title' => drupal_ucfirst($type->name),
      'title callback' => 'check_plain',
      'page callback' => 'node_add',
      'page arguments' => array(2),
      'access callback' => 'node_access',
      'access arguments' => array('create', $type->type),
      'description' => $type->description,
      'file' => 'node.pages.inc',
    );
    $items['admin/content/node-type/'. $type_url_str] = array(
      'title' => $type->name,
      'page callback' => 'drupal_get_form',
      'page arguments' => array('node_type_form', $type),
      'access arguments' => array('administer content types'),
      'file' => 'content_types.inc',
      'type' => MENU_CALLBACK,
    );
    $items['admin/content/node-type/'. $type_url_str .'/edit'] = array(
      'title' => 'Edit',
      'type' => MENU_DEFAULT_LOCAL_TASK,
    );
    $items['admin/content/node-type/'. $type_url_str .'/delete'] = array(
      'title' => 'Delete',
      'page arguments' => array('node_type_delete_confirm', $type),
      'access arguments' => array('administer content types'),
      'file' => 'content_types.inc',
      'type' => MENU_CALLBACK,
    );
  }
  $items['node/%node'] = array(
    'title callback' => 'node_page_title',
    'title arguments' => array(1),
    'page callback' => 'node_page_view',
    'page arguments' => array(1),
    'access callback' => 'node_access',
    'access arguments' => array('view', 1),
    'type' => MENU_CALLBACK);
  $items['node/%node/view'] = array(
    'title' => 'View',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10);
  $items['node/%node/edit'] = array(
    'title' => 'Edit',
    'page callback' => 'node_page_edit',
    'page arguments' => array(1),
    'access callback' => 'node_access',
    'access arguments' => array('update', 1),
    'weight' => 1,
    'file' => 'node.pages.inc',
    'type' => MENU_LOCAL_TASK,
  );
  $items['node/%node/delete'] = array(
    'title' => 'Delete',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('node_delete_confirm', 1),
    'access callback' => 'node_access',
    'access arguments' => array('delete', 1),
    'file' => 'node.pages.inc',
    'weight' => 1,
    'type' => MENU_CALLBACK);
  $items['node/%node/revisions'] = array(
    'title' => 'Revisions',
    'page callback' => 'node_revision_overview',
    'page arguments' => array(1),
    'access callback' => '_node_revision_access',
    'access arguments' => array(1),
    'weight' => 2,
    'file' => 'node.pages.inc',
    'type' => MENU_LOCAL_TASK,
  );
  $items['node/%node/revisions/%/view'] = array(
    'title' => 'Revisions',
    'load arguments' => array(3),
    'page callback' => 'node_show',
    'page arguments' => array(1, NULL, TRUE),
    'access callback' => '_node_revision_access',
    'access arguments' => array(1),
    'type' => MENU_CALLBACK,
  );
  $items['node/%node/revisions/%/revert'] = array(
    'title' => 'Revert to earlier revision',
    'load arguments' => array(3),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('node_revision_revert_confirm', 1),
    'access callback' => '_node_revision_access',
    'access arguments' => array(1, 'update'),
    'file' => 'node.pages.inc',
    'type' => MENU_CALLBACK,
  );
  $items['node/%node/revisions/%/delete'] = array(
    'title' => 'Delete earlier revision',
    'load arguments' => array(3),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('node_revision_delete_confirm', 1),
    'access callback' => '_node_revision_access',
    'access arguments' => array(1, 'delete'),
    'file' => 'node.pages.inc',
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/**
 * Title callback.
 */
function node_page_title($node) {
  return $node->title;
}

/**
 * Implementation of hook_init().
 */
function node_init() {
  drupal_add_css(drupal_get_path('module', 'node') .'/node.css');
}

function node_last_changed($nid) {
  $node = db_fetch_object(db_query('SELECT changed FROM {node} WHERE nid = %d', $nid));
  return ($node->changed);
}

/**
 * Return a list of all the existing revision numbers.
 */
function node_revision_list($node) {
  $revisions = array();
  $result = db_query('SELECT r.vid, r.title, r.log, r.uid, n.vid AS current_vid, r.timestamp, u.name FROM {node_revisions} r LEFT JOIN {node} n ON n.vid = r.vid INNER JOIN {users} u ON u.uid = r.uid WHERE r.nid = %d ORDER BY r.vid DESC', $node->nid);
  while ($revision = db_fetch_object($result)) {
    $revisions[$revision->vid] = $revision;
  }

  return $revisions;
}

/**
 * Implementation of hook_block().
 */
function node_block($op = 'list', $delta = 0) {
  if ($op == 'list') {
    $blocks[0]['info'] = t('Syndicate');
    // Not worth caching.
    $blocks[0]['cache'] = BLOCK_NO_CACHE;
    return $blocks;
  }
  else if ($op == 'view') {
    $block['subject'] = t('Syndicate');
    $block['content'] = theme('feed_icon', url('rss.xml'), t('Syndicate'));

    return $block;
  }
}

/**
 * A generic function for generating RSS feeds from a set of nodes.
 *
 * @param $nids
 *   An array of node IDs (nid). Defaults to FALSE so empty feeds can be
 *   generated with passing an empty array, if no items are to be added
 *   to the feed.
 * @param $channel
 *   An associative array containing title, link, description and other keys.
 *   The link should be an absolute URL.
 */
function node_feed($nids = FALSE, $channel = array()) {
  global $base_url, $language;

  if ($nids === FALSE) {
    $nids = array();
    $result = db_query_range(db_rewrite_sql('SELECT n.nid, n.created FROM {node} n WHERE n.promote = 1 AND n.status = 1 ORDER BY n.created DESC'), 0, variable_get('feed_default_items', 10));
    while ($row = db_fetch_object($result)) {
      $nids[] = $row->nid;
    }
  }

  $item_length = variable_get('feed_item_length', 'teaser');
  $namespaces = array('xmlns:dc' => 'http://purl.org/dc/elements/1.1/');

  $items = '';
  foreach ($nids as $nid) {
    // Load the specified node:
    $item = node_load($nid);
    $item->build_mode = NODE_BUILD_RSS;
    $item->link = url("node/$nid", array('absolute' => TRUE));

    if ($item_length != 'title') {
      $teaser = ($item_length == 'teaser') ? TRUE : FALSE;

      // Filter and prepare node teaser
      if (node_hook($item, 'view')) {
        $item = node_invoke($item, 'view', $teaser, FALSE);
      }
      else {
        $item = node_prepare($item, $teaser);
      }

      // Allow modules to change $node->content before the node is rendered.
      node_invoke_nodeapi($item, 'view', $teaser, FALSE);

      // Set the proper node property, then unset unused $node property so that a
      // bad theme can not open a security hole.
      $content = drupal_render($item->content);
      if ($teaser) {
        $item->teaser = $content;
        unset($item->body);
      }
      else {
        $item->body = $content;
        unset($item->teaser);
      }
    
      // Allow modules to modify the fully-built node.
      node_invoke_nodeapi($item, 'alter', $teaser, FALSE);
    }

    // Allow modules to add additional item fields and/or modify $item
    $extra = node_invoke_nodeapi($item, 'rss item');
    $extra = array_merge($extra, array(array('key' => 'pubDate', 'value' => gmdate('r', $item->created)), array('key' => 'dc:creator', 'value' => $item->name), array('key' => 'guid', 'value' => $item->nid .' at '. $base_url, 'attributes' => array('isPermaLink' => 'false'))));
    foreach ($extra as $element) {
      if (isset($element['namespace'])) {
        $namespaces = array_merge($namespaces, $element['namespace']);
      }
    }

    // Prepare the item description
    switch ($item_length) {
      case 'fulltext':
        $item_text = $item->body;
        break;
      case 'teaser':
        $item_text = $item->teaser;
        if (!empty($item->readmore)) {
          $item_text .= '<p>'. l(t('read more'), 'node/'. $item->nid, array('absolute' => TRUE, 'attributes' => array('target' => '_blank'))) .'</p>';
        }
        break;
      case 'title':
        $item_text = '';
        break;
    }

    $items .= format_rss_item($item->title, $item->link, $item_text, $extra);
  }

  $channel_defaults = array(
    'version'     => '2.0',
    'title'       => variable_get('site_name', 'Pressflow'),
    'link'        => $base_url,
    'description' => variable_get('site_mission', ''),
    'language'    => $language->language
  );
  $channel = array_merge($channel_defaults, $channel);

  $output = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n";
  $output .= "<rss version=\"". $channel["version"] ."\" xml:base=\"". $base_url ."\" ". drupal_attributes($namespaces) .">\n";
  $output .= format_rss_channel($channel['title'], $channel['link'], $channel['description'], $items, $channel['language']);
  $output .= "</rss>\n";

  drupal_set_header('Content-Type: application/rss+xml; charset=utf-8');
  print $output;
}

/**
 * Menu callback; Generate a listing of promoted nodes.
 */
function node_page_default() {
  $result = pager_query(db_rewrite_sql('SELECT n.nid, n.sticky, n.created FROM {node} n WHERE n.promote = 1 AND n.status = 1 ORDER BY n.sticky DESC, n.created DESC'), variable_get('default_nodes_main', 10));

  $output = '';
  $num_rows = FALSE;
  while ($node = db_fetch_object($result)) {
    $output .= node_view(node_load($node->nid), 1);
    $num_rows = TRUE;
  }

  if ($num_rows) {
    $feed_url = url('rss.xml', array('absolute' => TRUE));
    drupal_add_feed($feed_url, variable_get('site_name', 'Pressflow') .' '. t('RSS'));
    $output .= theme('pager', NULL, variable_get('default_nodes_main', 10));
  }
  else {
    $default_message = t('<h1 class="title">Welcome to your new Pressflow website!</h1><p>Please follow these steps to set up and start using your website:</p>');
    $default_message .= '<ol>';

    $default_message .= '<li>'. t('<strong>Configure your website</strong> Once logged in, visit the <a href="@admin">administration section</a>, where you can <a href="@config">customize and configure</a> all aspects of your website.', array('@admin' => url('admin'), '@config' => url('admin/settings'))) .'</li>';
    $default_message .= '<li>'. t('<strong>Enable additional functionality</strong> Next, visit the <a href="@modules">module list</a> and enable features which suit your specific needs. You can find additional modules in the <a href="@download_modules">Drupal modules download section</a>.', array('@modules' => url('admin/build/modules'), '@download_modules' => 'http://drupal.org/project/modules')) .'</li>';
    $default_message .= '<li>'. t('<strong>Customize your website design</strong> To change the "look and feel" of your website, visit the <a href="@themes">themes section</a>. You may choose from one of the included themes or download additional themes from the <a href="@download_themes">Drupal themes download section</a>.', array('@themes' => url('admin/build/themes'), '@download_themes' => 'http://drupal.org/project/themes')) .'</li>';
    $default_message .= '<li>'. t('<strong>Start posting content</strong> Finally, you can <a href="@content">create content</a> for your website. This message will disappear once you have promoted a post to the front page.', array('@content' => url('node/add'))) .'</li>';
    $default_message .= '</ol>';
    $default_message .= '<p>'. t('For more information, please refer to the <a href="@help">help section</a>, or the <a href="@handbook">online Drupal handbooks</a>. You may also post at the <a href="@forum">Drupal forum</a>, or view the wide range of <a href="@support">other support options</a> available.', array('@help' => url('admin/help'), '@handbook' => 'http://drupal.org/handbooks', '@forum' => 'http://drupal.org/forum', '@support' => 'http://drupal.org/support')) .'</p>';

    $output = '<div id="first-time">'. $default_message .'</div>';
  }
  drupal_set_title('');

  return $output;
}

/**
 * Menu callback; view a single node.
 */
function node_page_view($node, $cid = NULL) {
  drupal_set_title(check_plain($node->title));
  return node_show($node, $cid);
}

/**
 * Implementation of hook_update_index().
 */
function node_update_index() {
  $limit = (int)variable_get('search_cron_limit', 100);

  // Store the maximum possible comments per thread (used for ranking by reply count)
  variable_set('node_cron_comments_scale', 1.0 / max(1, db_result(db_query('SELECT MAX(comment_count) FROM {node_comment_statistics}'))));
  variable_set('node_cron_views_scale', 1.0 / max(1, db_result(db_query('SELECT MAX(totalcount) FROM {node_counter}'))));

  $result = db_query_range("SELECT n.nid FROM {node} n LEFT JOIN {search_dataset} d ON d.type = 'node' AND d.sid = n.nid WHERE d.sid IS NULL OR d.reindex <> 0 ORDER BY d.reindex ASC, n.nid ASC", 0, $limit);

  while ($node = db_fetch_object($result)) {
    _node_index_node($node);
  }
}

/**
 * Index a single node.
 *
 * @param $node
 *   The node to index.
 */
function _node_index_node($node) {
  $node = node_load($node->nid);

  // save the changed time of the most recent indexed node, for the search results half-life calculation
  variable_set('node_cron_last', $node->changed);

  // Build the node body.
  $node->build_mode = NODE_BUILD_SEARCH_INDEX;
  $node = node_build_content($node, FALSE, FALSE);
  $node->body = drupal_render($node->content);

  $text = '<h1>'. check_plain($node->title) .'</h1>'. $node->body;

  // Fetch extra data normally not visible
  $extra = node_invoke_nodeapi($node, 'update index');
  foreach ($extra as $t) {
    $text .= $t;
  }

  // Update index
  search_index($node->nid, 'node', $text);
}

/**
 * Implementation of hook_form_alter().
 */
function node_form_alter(&$form, $form_state, $form_id) {
  // Advanced node search form
  if ($form_id == 'search_form' && $form['module']['#value'] == 'node' && user_access('use advanced search')) {
    // Keyword boxes:
    $form['advanced'] = array(
      '#type' => 'fieldset',
      '#title' => t('Advanced search'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
      '#attributes' => array('class' => 'search-advanced'),
    );
    $form['advanced']['keywords'] = array(
      '#prefix' => '<div class="criterion">',
      '#suffix' => '</div>',
    );
    $form['advanced']['keywords']['or'] = array(
      '#type' => 'textfield',
      '#title' => t('Containing any of the words'),
      '#size' => 30,
      '#maxlength' => 255,
    );
    $form['advanced']['keywords']['phrase'] = array(
      '#type' => 'textfield',
      '#title' => t('Containing the phrase'),
      '#size' => 30,
      '#maxlength' => 255,
    );
    $form['advanced']['keywords']['negative'] = array(
      '#type' => 'textfield',
      '#title' => t('Containing none of the words'),
      '#size' => 30,
      '#maxlength' => 255,
    );

    // Taxonomy box:
    if ($taxonomy = module_invoke('taxonomy', 'form_all', 1)) {
      $form['advanced']['category'] = array(
        '#type' => 'select',
        '#title' => t('Only in the category(s)'),
        '#prefix' => '<div class="criterion">',
        '#size' => 10,
        '#suffix' => '</div>',
        '#options' => $taxonomy,
        '#multiple' => TRUE,
      );
    }

    // Node types:
    $types = array_map('check_plain', node_get_types('names'));
    $form['advanced']['type'] = array(
      '#type' => 'checkboxes',
      '#title' => t('Only of the type(s)'),
      '#prefix' => '<div class="criterion">',
      '#suffix' => '</div>',
      '#options' => $types,
    );
    $form['advanced']['submit'] = array(
      '#type' => 'submit',
      '#value' => t('Advanced search'),
      '#prefix' => '<div class="action">',
      '#suffix' => '</div>',
    );

    $form['#validate'][] = 'node_search_validate';
  }
}

/**
 * Form API callback for the search form. Registered in node_form_alter().
 */
function node_search_validate($form, &$form_state) {
  // Initialise using any existing basic search keywords.
  $keys = $form_state['values']['processed_keys'];

  // Insert extra restrictions into the search keywords string.
  if (isset($form_state['values']['type']) && is_array($form_state['values']['type'])) {
    // Retrieve selected types - Forms API sets the value of unselected checkboxes to 0.
    $form_state['values']['type'] = array_filter($form_state['values']['type']);
    if (count($form_state['values']['type'])) {
      $keys = search_query_insert($keys, 'type', implode(',', array_keys($form_state['values']['type'])));
    }
  }

  if (isset($form_state['values']['category']) && is_array($form_state['values']['category'])) {
    $keys = search_query_insert($keys, 'category', implode(',', $form_state['values']['category']));
  }
  if ($form_state['values']['or'] != '') {
    if (preg_match_all('/ ("[^"]+"|[^" ]+)/i', ' '. $form_state['values']['or'], $matches)) {
      $keys .= ' '. implode(' OR ', $matches[1]);
    }
  }
  if ($form_state['values']['negative'] != '') {
    if (preg_match_all('/ ("[^"]+"|[^" ]+)/i', ' '. $form_state['values']['negative'], $matches)) {
      $keys .= ' -'. implode(' -', $matches[1]);
    }
  }
  if ($form_state['values']['phrase'] != '') {
    $keys .= ' "'. str_replace('"', ' ', $form_state['values']['phrase']) .'"';
  }
  if (!empty($keys)) {
    form_set_value($form['basic']['inline']['processed_keys'], trim($keys), $form_state);
  }
}

/**
 * @defgroup node_access Node access rights
 * @{
 * The node access system determines who can do what to which nodes.
 *
 * In determining access rights for a node, node_access() first checks
 * whether the user has the "administer nodes" permission. Such users have
 * unrestricted access to all nodes. Then the node module's hook_access()
 * is called, and a TRUE or FALSE return value will grant or deny access.
 * This allows, for example, the blog module to always grant access to the
 * blog author, and for the book module to always deny editing access to
 * PHP pages.
 *
 * If node module does not intervene (returns NULL), then the
 * node_access table is used to determine access. All node access
 * modules are queried using hook_node_grants() to assemble a list of
 * "grant IDs" for the user. This list is compared against the table.
 * If any row contains the node ID in question (or 0, which stands for "all
 * nodes"), one of the grant IDs returned, and a value of TRUE for the
 * operation in question, then access is granted. Note that this table is a
 * list of grants; any matching row is sufficient to grant access to the
 * node.
 *
 * In node listings, the process above is followed except that
 * hook_access() is not called on each node for performance reasons and for
 * proper functioning of the pager system. When adding a node listing to your
 * module, be sure to use db_rewrite_sql() to add
 * the appropriate clauses to your query for access checks.
 *
 * To see how to write a node access module of your own, see
 * node_access_example.module.
 */

/**
 * Determine whether the current user may perform the given operation on the
 * specified node.
 *
 * @param $op
 *   The operation to be performed on the node. Possible values are:
 *   - "view"
 *   - "update"
 *   - "delete"
 *   - "create"
 * @param $node
 *   The node object (or node array) on which the operation is to be performed,
 *   or node type (e.g. 'forum') for "create" operation.
 * @param $account
 *   Optional, a user object representing the user for whom the operation is to
 *   be performed. Determines access for a user other than the current user.
 * @return
 *   TRUE if the operation may be performed, or FALSE otherwise.
 */
function node_access($op, $node, $account = NULL) {
  global $user;

  if (!$node || !in_array($op, array('view', 'update', 'delete', 'create'), TRUE)) {
    // If there was no node to check against, or the $op was not one of the
    // supported ones, we return access denied.
    return FALSE;
  }
  // Convert the node to an object if necessary:
  if ($op != 'create') {
    $node = (object)$node;
  }
  // If no user object is supplied, the access check is for the current user.
  if (empty($account)) {
    $account = $user;
  }
  // If the node is in a restricted format, disallow editing.
  if ($op == 'update' && !filter_access($node->format)) {
    return FALSE;
  }

  if (user_access('administer nodes', $account)) {
    return TRUE;
  }

  if (!user_access('access content', $account)) {
    return FALSE;
  }

  // Can't use node_invoke(), because the access hook takes the $op parameter
  // before the $node parameter.
  $module = node_get_types('module', $node);
  if ($module == 'node') {
    $module = 'node_content'; // Avoid function name collisions.
  }
  $access = module_invoke($module, 'access', $op, $node, $account);
  if (!is_null($access)) {
    return $access;
  }

  // If the module did not override the access rights, use those set in the
  // node_access table.
  if ($op != 'create' && $node->nid && $node->status) {
    $grants = array();
    foreach (node_access_grants($op, $account) as $realm => $gids) {
      foreach ($gids as $gid) {
        $grants[] = "(gid = $gid AND realm = '$realm')";
      }
    }

    $grants_sql = '';
    if (count($grants)) {
      $grants_sql = 'AND ('. implode(' OR ', $grants) .')';
    }

    $sql = "SELECT 1 FROM {node_access} WHERE (nid = 0 OR nid = %d) $grants_sql AND grant_$op >= 1";
    $result = db_query_range($sql, $node->nid, 0, 1);
    return (bool) db_result($result);
  }

  // Let authors view their own nodes.
  if ($op == 'view' && $account->uid == $node->uid && $account->uid != 0) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Generate an SQL join clause for use in fetching a node listing.
 *
 * @param $node_alias
 *   If the node table has been given an SQL alias other than the default
 *   "n", that must be passed here.
 * @param $node_access_alias
 *   If the node_access table has been given an SQL alias other than the default
 *   "na", that must be passed here.
 * @return
 *   An SQL join clause.
 */
function _node_access_join_sql($node_alias = 'n', $node_access_alias = 'na') {
  if (user_access('administer nodes')) {
    return '';
  }

  return 'INNER JOIN {node_access} '. $node_access_alias .' ON '. $node_access_alias .'.nid = '. $node_alias .'.nid';
}

/**
 * Generate an SQL where clause for use in fetching a node listing.
 *
 * @param $op
 *   The operation that must be allowed to return a node.
 * @param $node_access_alias
 *   If the node_access table has been given an SQL alias other than the default
 *   "na", that must be passed here.
 * @param $account
 *   The user object for the user performing the operation. If omitted, the
 *   current user is used.
 * @return
 *   An SQL where clause.
 */
function _node_access_where_sql($op = 'view', $node_access_alias = 'na', $account = NULL) {
  if (user_access('administer nodes')) {
    return;
  }

  $grants = array();
  foreach (node_access_grants($op, $account) as $realm => $gids) {
    foreach ($gids as $gid) {
      $grants[] = "($node_access_alias.gid = $gid AND $node_access_alias.realm = '$realm')";
    }
  }

  $grants_sql = '';
  if (count($grants)) {
    $grants_sql = 'AND ('. implode(' OR ', $grants) .')';
  }

  $sql = "$node_access_alias.grant_$op >= 1 $grants_sql";
  return $sql;
}

/**
 * Fetch an array of permission IDs granted to the given user ID.
 *
 * The implementation here provides only the universal "all" grant. A node
 * access module should implement hook_node_grants() to provide a grant
 * list for the user.
 *
 * @param $op
 *   The operation that the user is trying to perform.
 * @param $account
 *   The user object for the user performing the operation. If omitted, the
 *   current user is used.
 * @return
 *   An associative array in which the keys are realms, and the values are
 *   arrays of grants for those realms.
 */
function node_access_grants($op, $account = NULL) {

  if (!isset($account)) {
    $account = $GLOBALS['user'];
  }

  return array_merge(array('all' => array(0)), module_invoke_all('node_grants', $account, $op));
}

/**
 * Determine whether the user has a global viewing grant for all nodes.
 */
function node_access_view_all_nodes() {
  static $access;

  if (!isset($access)) {
    $grants = array();
    foreach (node_access_grants('view') as $realm => $gids) {
      foreach ($gids as $gid) {
        $grants[] = "(gid = $gid AND realm = '$realm')";
      }
    }

    $grants_sql = '';
    if (count($grants)) {
      $grants_sql = 'AND ('. implode(' OR ', $grants) .')';
    }

    $sql = "SELECT COUNT(*) FROM {node_access} WHERE nid = 0 $grants_sql AND grant_view >= 1";
    $result = db_query($sql);
    $access = db_result($result);
  }

  return $access;
}

/**
 * Implementation of hook_db_rewrite_sql
 */
function node_db_rewrite_sql($query, $primary_table, $primary_field) {
  if ($primary_field == 'nid' && !node_access_view_all_nodes()) {
    $return['join'] = _node_access_join_sql($primary_table);
    $return['where'] = _node_access_where_sql();
    $return['distinct'] = 1;
    return $return;
  }
}

/**
 * Gets the list of node access grants and writes them to the database.
 *
 * This function is called when a node is saved, and can also be called by
 * modules if something other than a node save causes node access permissions
 * to change. It collects all node access grants for the node from
 * hook_node_access_records() implementations and saves the collected
 * grants to the database.
 *
 * @param $node
 *   The $node to acquire grants for.
 */
function node_access_acquire_grants($node) {
  $grants = module_invoke_all('node_access_records', $node);
  if (empty($grants)) {
    $grants[] = array('realm' => 'all', 'gid' => 0, 'grant_view' => 1, 'grant_update' => 0, 'grant_delete' => 0);
  }
  else {
    // retain grants by highest priority
    $grant_by_priority = array();
    foreach ($grants as $g) {
      $grant_by_priority[intval($g['priority'])][] = $g;
    }
    krsort($grant_by_priority);
    $grants = array_shift($grant_by_priority);
  }

  node_access_write_grants($node, $grants);
}

/**
 * Writes a list of grants to the database, deleting any previously saved ones.
 *
 * If a realm is provided, it will only delete grants from that realm, but it
 * will always delete a grant from the 'all' realm. Modules that utilize
 * node_access can use this function when doing mass updates due to widespread
 * permission changes.
 *
 * @param $node
 *   The $node being written to. All that is necessary is that it contain a nid.
 * @param $grants
 *   A list of grants to write. Each grant is an array that must contain the
 *   following keys: realm, gid, grant_view, grant_update, grant_delete.
 *   The realm is specified by a particular module; the gid is as well, and
 *   is a module-defined id to define grant privileges. each grant_* field
 *   is a boolean value.
 * @param $realm
 *   If provided, only read/write grants for that realm.
 * @param $delete
 *   If false, do not delete records. This is only for optimization purposes,
 *   and assumes the caller has already performed a mass delete of some form.
 */
function node_access_write_grants($node, $grants, $realm = NULL, $delete = TRUE) {
  if ($delete) {
    $query = 'DELETE FROM {node_access} WHERE nid = %d';
    if ($realm) {
      $query .= " AND realm in ('%s', 'all')";
    }
    db_query($query, $node->nid, $realm);
  }

  // Only perform work when node_access modules are active.
  if (count(module_implements('node_grants'))) {
    foreach ($grants as $grant) {
      if ($realm && $realm != $grant['realm']) {
        continue;
      }
      // Only write grants; denies are implicit.
      if ($grant['grant_view'] || $grant['grant_update'] || $grant['grant_delete']) {
        db_query("INSERT INTO {node_access} (nid, realm, gid, grant_view, grant_update, grant_delete) VALUES (%d, '%s', %d, %d, %d, %d)", $node->nid, $grant['realm'], $grant['gid'], $grant['grant_view'], $grant['grant_update'], $grant['grant_delete']);
      }
    }
  }
}

/**
 * Flag / unflag the node access grants for rebuilding, or read the current
 * value of the flag.
 *
 * When the flag is set, a message is displayed to users with 'access
 * administration pages' permission, pointing to the 'rebuild' confirm form.
 * This can be used as an alternative to direct node_access_rebuild calls,
 * allowing administrators to decide when they want to perform the actual
 * (possibly time consuming) rebuild.
 * When unsure the current user is an adminisrator, node_access_rebuild
 * should be used instead.
 *
 * @param $rebuild
 *   (Optional) The boolean value to be written.
  * @return
 *   (If no value was provided for $rebuild) The current value of the flag.
 */
function node_access_needs_rebuild($rebuild = NULL) {
  if (!isset($rebuild)) {
    return variable_get('node_access_needs_rebuild', FALSE);
  }
  elseif ($rebuild) {
    variable_set('node_access_needs_rebuild', TRUE);
  }
  else {
    variable_del('node_access_needs_rebuild');
  }
}

/**
 * Rebuild the node access database. This is occasionally needed by modules
 * that make system-wide changes to access levels.
 *
 * When the rebuild is required by an admin-triggered action (e.g module
 * settings form), calling node_access_needs_rebuild(TRUE) instead of
 * node_access_rebuild() lets the user perform his changes and actually
 * rebuild only once he is done.
 *
 * Note : As of Drupal 6, node access modules are not required to (and actually
 * should not) call node_access_rebuild() in hook_enable/disable anymore.
 *
 * @see node_access_needs_rebuild()
 *
 * @param $batch_mode
 *   Set to TRUE to process in 'batch' mode, spawning processing over several
 *   HTTP requests (thus avoiding the risk of PHP timeout if the site has a
 *   large number of nodes).
 *   hook_update_N and any form submit handler are safe contexts to use the
 *   'batch mode'. Less decidable cases (such as calls from hook_user,
 *   hook_taxonomy, hook_node_type...) might consider using the non-batch mode.
 */
function node_access_rebuild($batch_mode = FALSE) {
  db_query("DELETE FROM {node_access}");
  // Only recalculate if the site is using a node_access module.
  if (count(module_implements('node_grants'))) {
    if ($batch_mode) {
      $batch = array(
        'title' => t('Rebuilding content access permissions'),
        'operations' => array(
          array('_node_access_rebuild_batch_operation', array()),
        ),
        'finished' => '_node_access_rebuild_batch_finished'
      );
      batch_set($batch);
    }
    else {
      // Try to allocate enough time to rebuild node grants
      if (function_exists('set_time_limit')) {
        @set_time_limit(240);
      }
      $result = db_query("SELECT nid FROM {node}");
      while ($node = db_fetch_object($result)) {
        $loaded_node = node_load($node->nid, NULL, TRUE);
        // To preserve database integrity, only aquire grants if the node
        // loads successfully.
        if (!empty($loaded_node)) {
          node_access_acquire_grants($loaded_node);
        }
      }
    }
  }
  else {
    // Not using any node_access modules. Add the default grant.
    db_query("INSERT INTO {node_access} VALUES (0, 0, 'all', 1, 0, 0)");
  }

  if (!isset($batch)) {
    drupal_set_message(t('Content permissions have been rebuilt.'));
    node_access_needs_rebuild(FALSE);
    cache_clear_all();
  }
}

/**
 * Batch operation for node_access_rebuild_batch.
 *
 * This is a mutlistep operation : we go through all nodes by packs of 20.
 * The batch processing engine interrupts processing and sends progress
 * feedback after 1 second execution time.
 */
function _node_access_rebuild_batch_operation(&$context) {
  if (empty($context['sandbox'])) {
    // Initiate multistep processing.
    $context['sandbox']['progress'] = 0;
    $context['sandbox']['current_node'] = 0;
    $context['sandbox']['max'] = db_result(db_query('SELECT COUNT(DISTINCT nid) FROM {node}'));
  }

  // Process the next 20 nodes.
  $limit = 20;
  $result = db_query_range("SELECT nid FROM {node} WHERE nid > %d ORDER BY nid ASC", $context['sandbox']['current_node'], 0, $limit);
  while ($row = db_fetch_array($result)) {
    $loaded_node = node_load($row['nid'], NULL, TRUE);
    // To preserve database integrity, only aquire grants if the node
    // loads successfully.
    if (!empty($loaded_node)) {
      node_access_acquire_grants($loaded_node);
    }
    $context['sandbox']['progress']++;
    $context['sandbox']['current_node'] = $row['nid'];
  }

  // Multistep processing : report progress.
  if ($context['sandbox']['progress'] != $context['sandbox']['max']) {
    $context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['max'];
  }
}

/**
 * Post-processing for node_access_rebuild_batch.
 */
function _node_access_rebuild_batch_finished($success, $results, $operations) {
  if ($success) {
    drupal_set_message(t('The content access permissions have been rebuilt.'));
    node_access_needs_rebuild(FALSE);
  }
  else {
    drupal_set_message(t('The content access permissions have not been properly rebuilt.'), 'error');
  }
  cache_clear_all();
}

/**
 * @} End of "defgroup node_access".
 */


/**
 * @defgroup node_content Hook implementations for user-created content types.
 * @{
 */

/**
 * Implementation of hook_access().
 *
 * Named so as not to conflict with node_access()
 */
function node_content_access($op, $node, $account) {
  $type = is_string($node) ? $node : (is_array($node) ? $node['type'] : $node->type);

  if ($op == 'create') {
    return user_access('create '. $type .' content', $account);
  }

  if ($op == 'update') {
    if (user_access('edit any '. $type .' content', $account) || (user_access('edit own '. $type .' content', $account) && ($account->uid == $node->uid))) {
      return TRUE;
    }
  }

  if ($op == 'delete') {
    if (user_access('delete any '. $type .' content', $account) || (user_access('delete own '. $type .' content', $account) && ($account->uid == $node->uid))) {
      return TRUE;
    }
  }
}

/**
 * Implementation of hook_form().
 */
function node_content_form($node, $form_state) {
  $type = node_get_types('type', $node);
  $form = array();

  if ($type->has_title) {
    $form['title'] = array(
      '#type' => 'textfield',
      '#title' => check_plain($type->title_label),
      '#required' => TRUE,
      '#default_value' => $node->title,
      '#maxlength' => 255,
      '#weight' => -5,
    );
  }

  if ($type->has_body) {
    $form['body_field'] = node_body_field($node, $type->body_label, $type->min_word_count);
  }

  return $form;
}

/**
 * @} End of "defgroup node_content".
 */

/**
 * Implementation of hook_forms(). All node forms share the same form handler
 */
function node_forms() {
  $forms = array();
  if ($types = node_get_types()) {
    foreach (array_keys($types) as $type) {
      $forms[$type .'_node_form']['callback'] = 'node_form';
    }
  }
  return $forms;
}

/**
 * Format the "Submitted by username on date/time" for each node
 *
 * @ingroup themeable
 */
function theme_node_submitted($node) {
  return t('Submitted by !username on @datetime',
    array(
      '!username' => theme('username', $node),
      '@datetime' => format_date($node->created),
    ));
}

/**
 * Implementation of hook_hook_info().
 */
function node_hook_info() {
  return array(
    'node' => array(
      'nodeapi' => array(
        'presave' => array(
          'runs when' => t('When either saving a new post or updating an existing post'),
        ),
        'insert' => array(
          'runs when' => t('After saving a new post'),
        ),
        'update' => array(
          'runs when' => t('After saving an updated post'),
        ),
        'delete' => array(
          'runs when' => t('After deleting a post')
        ),
        'view' => array(
          'runs when' => t('When content is viewed by an authenticated user')
        ),
      ),
    ),
  );
}

/**
 * Implementation of hook_action_info().
 */
function node_action_info() {
  return array(
    'node_publish_action' => array(
      'type' => 'node',
      'description' => t('Publish post'),
      'configurable' => FALSE,
      'behavior' => array('changes_node_property'),
      'hooks' => array(
        'nodeapi' => array('presave'),
        'comment' => array('insert', 'update'),
      ),
    ),
    'node_unpublish_action' => array(
      'type' => 'node',
      'description' => t('Unpublish post'),
      'configurable' => FALSE,
      'behavior' => array('changes_node_property'),
      'hooks' => array(
        'nodeapi' => array('presave'),
        'comment' => array('delete', 'insert', 'update'),
      ),
    ),
    'node_make_sticky_action' => array(
      'type' => 'node',
      'description' => t('Make post sticky'),
      'configurable' => FALSE,
      'behavior' => array('changes_node_property'),
      'hooks' => array(
        'nodeapi' => array('presave'),
        'comment' => array('insert', 'update'),
      ),
    ),
    'node_make_unsticky_action' => array(
      'type' => 'node',
      'description' => t('Make post unsticky'),
      'configurable' => FALSE,
      'behavior' => array('changes_node_property'),
      'hooks' => array(
        'nodeapi' => array('presave'),
        'comment' => array('delete', 'insert', 'update'),
      ),
    ),
    'node_promote_action' => array(
      'type' => 'node',
      'description' => t('Promote post to front page'),
      'configurable' => FALSE,
      'behavior' => array('changes_node_property'),
      'hooks' => array(
        'nodeapi' => array('presave'),
        'comment' => array('insert', 'update'),
      ),
    ),
    'node_unpromote_action' => array(
      'type' => 'node',
      'description' => t('Remove post from front page'),
      'configurable' => FALSE,
      'behavior' => array('changes_node_property'),
      'hooks' => array(
        'nodeapi' => array('presave'),
        'comment' => array('delete', 'insert', 'update'),
      ),
    ),
    'node_assign_owner_action' => array(
      'type' => 'node',
      'description' => t('Change the author of a post'),
      'configurable' => TRUE,
      'behavior' => array('changes_node_property'),
      'hooks' => array(
        'any' => TRUE,
        'nodeapi' => array('presave'),
        'comment' => array('delete', 'insert', 'update'),
      ),
    ),
    'node_save_action' => array(
      'type' => 'node',
      'description' => t('Save post'),
      'configurable' => FALSE,
      'hooks' => array(
        'comment' => array('delete', 'insert', 'update'),
      ),
    ),
    'node_unpublish_by_keyword_action' => array(
      'type' => 'node',
      'description' => t('Unpublish post containing keyword(s)'),
      'configurable' => TRUE,
      'hooks' => array(
        'nodeapi' => array('presave', 'insert', 'update'),
      ),
    ),
  );
}

/**
 * Implementation of a Drupal action.
 * Sets the status of a node to 1, meaning published.
 */
function node_publish_action(&$node, $context = array()) {
  $node->status = 1;
  watchdog('action', 'Set @type %title to published.', array('@type' => node_get_types('name', $node), '%title' => $node->title));
}

/**
 * Implementation of a Drupal action.
 * Sets the status of a node to 0, meaning unpublished.
 */
function node_unpublish_action(&$node, $context = array()) {
  $node->status = 0;
  watchdog('action', 'Set @type %title to unpublished.', array('@type' => node_get_types('name', $node), '%title' => $node->title));
}

/**
 * Implementation of a Drupal action.
 * Sets the sticky-at-top-of-list property of a node to 1.
 */
function node_make_sticky_action(&$node, $context = array()) {
  $node->sticky = 1;
  watchdog('action', 'Set @type %title to sticky.', array('@type' => node_get_types('name', $node), '%title' => $node->title));
}

/**
 * Implementation of a Drupal action.
 * Sets the sticky-at-top-of-list property of a node to 0.
 */
function node_make_unsticky_action(&$node, $context = array()) {
  $node->sticky = 0;
  watchdog('action', 'Set @type %title to unsticky.', array('@type' => node_get_types('name', $node), '%title' => $node->title));
}

/**
 * Implementation of a Drupal action.
 * Sets the promote property of a node to 1.
 */
function node_promote_action(&$node, $context = array()) {
  $node->promote = 1;
  watchdog('action', 'Promoted @type %title to front page.', array('@type' => node_get_types('name', $node), '%title' => $node->title));
}

/**
 * Implementation of a Drupal action.
 * Sets the promote property of a node to 0.
 */
function node_unpromote_action(&$node, $context = array()) {
  $node->promote = 0;
  watchdog('action', 'Removed @type %title from front page.', array('@type' => node_get_types('name', $node), '%title' => $node->title));
}

/**
 * Implementation of a Drupal action.
 * Saves a node.
 */
function node_save_action($node) {
  node_save($node);
  watchdog('action', 'Saved @type %title', array('@type' => node_get_types('name', $node), '%title' => $node->title));
}

/**
 * Implementation of a configurable Drupal action.
 * Assigns ownership of a node to a user.
 */
function node_assign_owner_action(&$node, $context) {
  $node->uid = $context['owner_uid'];
  $owner_name = db_result(db_query("SELECT name FROM {users} WHERE uid = %d", $context['owner_uid']));
  watchdog('action', 'Changed owner of @type %title to uid %name.', array('@type' => node_get_types('name', $node), '%title' => $node->title, '%name' => $owner_name));
}

function node_assign_owner_action_form($context) {
  $description = t('The username of the user to which you would like to assign ownership.');
  $count = db_result(db_query("SELECT COUNT(*) FROM {users}"));
  $owner_name = '';
  if (isset($context['owner_uid'])) {
    $owner_name = db_result(db_query("SELECT name FROM {users} WHERE uid = %d", $context['owner_uid']));
  }

  // Use dropdown for fewer than 200 users; textbox for more than that.
  if (intval($count) < 200) {
    $options = array();
    $result = db_query("SELECT uid, name FROM {users} WHERE uid > 0 ORDER BY name");
    while ($data = db_fetch_object($result)) {
      $options[$data->name] = $data->name;
    }
    $form['owner_name'] = array(
      '#type' => 'select',
      '#title' => t('Username'),
      '#default_value' => $owner_name,
      '#options' => $options,
      '#description' => $description,
    );
  }
  else {
    $form['owner_name'] = array(
      '#type' => 'textfield',
      '#title' => t('Username'),
      '#default_value' => $owner_name,
      '#autocomplete_path' => 'user/autocomplete',
      '#size' => '6',
      '#maxlength' => '60',
      '#description' => $description,
    );
  }
  return $form;
}

function node_assign_owner_action_validate($form, $form_state) {
  $count = db_result(db_query("SELECT COUNT(*) FROM {users} WHERE name = '%s'", $form_state['values']['owner_name']));
  if (intval($count) != 1) {
    form_set_error('owner_name', t('Please enter a valid username.'));
  }
}

function node_assign_owner_action_submit($form, $form_state) {
  // Username can change, so we need to store the ID, not the username.
  $uid = db_result(db_query("SELECT uid from {users} WHERE name = '%s'", $form_state['values']['owner_name']));
  return array('owner_uid' => $uid);
}

function node_unpublish_by_keyword_action_form($context) {
  $form['keywords'] = array(
    '#title' => t('Keywords'),
    '#type' => 'textarea',
    '#description' => t('The post will be unpublished if it contains any of the character sequences above. Use a comma-separated list of character sequences. Example: funny, bungee jumping, "Company, Inc.". Character sequences are case-sensitive.'),
    '#default_value' => isset($context['keywords']) ? drupal_implode_tags($context['keywords']) : '',
  );
  return $form;
}

function node_unpublish_by_keyword_action_submit($form, $form_state) {
  return array('keywords' => drupal_explode_tags($form_state['values']['keywords']));
}

/**
 * Implementation of a configurable Drupal action.
 * Unpublish a node if it contains a certain string.
 *
 * @param $context
 *   An array providing more information about the context of the call to this action.
 * @param $comment
 *   A node object.
 */
function node_unpublish_by_keyword_action($node, $context) {
  foreach ($context['keywords'] as $keyword) {
    if (strstr(node_view(drupal_clone($node)), $keyword) || strstr($node->title, $keyword)) {
      $node->status = 0;
      watchdog('action', 'Set @type %title to unpublished.', array('@type' => node_get_types('name', $node), '%title' => $node->title));
      break;
    }
  }
}
