<?php

/**
 * @file
 * Enables users to comment on published content.
 *
 * When enabled, the Drupal comment module creates a discussion
 * board for each Drupal node. Users can post comments to discuss
 * a forum topic, weblog post, story, collaborative book page, etc.
 */

/**
 * Comment is published.
 */
define('COMMENT_PUBLISHED', 0);

/**
 * Comment is awaiting approval.
 */
define('COMMENT_NOT_PUBLISHED', 1);

/**
 * Comments are displayed in a flat list - collapsed.
 */
define('COMMENT_MODE_FLAT_COLLAPSED', 1);

/**
 * Comments are displayed in a flat list - expanded.
 */
define('COMMENT_MODE_FLAT_EXPANDED', 2);

/**
 * Comments are displayed as a threaded list - collapsed.
 */
define('COMMENT_MODE_THREADED_COLLAPSED', 3);

/**
 * Comments are displayed as a threaded list - expanded.
 */
define('COMMENT_MODE_THREADED_EXPANDED', 4);

/**
 * Comments are ordered by date - newest first.
 */
define('COMMENT_ORDER_NEWEST_FIRST', 1);

/**
 * Comments are ordered by date - oldest first.
 */
define('COMMENT_ORDER_OLDEST_FIRST', 2);

/**
 * Comment controls should be shown above the comment list.
 */
define('COMMENT_CONTROLS_ABOVE', 0);

/**
 * Comment controls should be shown below the comment list.
 */
define('COMMENT_CONTROLS_BELOW', 1);

/**
 * Comment controls should be shown both above and below the comment list.
 */
define('COMMENT_CONTROLS_ABOVE_BELOW', 2);

/**
 * Comment controls are hidden.
 */
define('COMMENT_CONTROLS_HIDDEN', 3);

/**
 * Anonymous posters may not enter their contact information.
 */
define('COMMENT_ANONYMOUS_MAYNOT_CONTACT', 0);

/**
 * Anonymous posters may leave their contact information.
 */
define('COMMENT_ANONYMOUS_MAY_CONTACT', 1);

/**
 * Anonymous posters must leave their contact information.
 */
define('COMMENT_ANONYMOUS_MUST_CONTACT', 2);

/**
 * Comment form should be displayed on a separate page.
 */
define('COMMENT_FORM_SEPARATE_PAGE', 0);

/**
 * Comment form should be shown below post or list of comments.
 */
define('COMMENT_FORM_BELOW', 1);

/**
 * Comments for this node are disabled.
 */
define('COMMENT_NODE_DISABLED', 0);

/**
 * Comments for this node are locked.
 */
define('COMMENT_NODE_READ_ONLY', 1);

/**
 * Comments are enabled on this node.
 */
define('COMMENT_NODE_READ_WRITE', 2);

/**
 * Comment preview is optional.
 */
define('COMMENT_PREVIEW_OPTIONAL', 0);

/**
 * Comment preview is required.
 */
define('COMMENT_PREVIEW_REQUIRED', 1);

/**
 * Implementation of hook_help().
 */
function comment_help($path, $arg) {
  switch ($path) {
    case 'admin/help#comment':
      $output = '<p>'. t('The comment module allows visitors to comment on your posts, creating ad hoc discussion boards. Any <a href="@content-type">content type</a> may have its <em>Default comment setting</em> set to <em>Read/Write</em> to allow comments, or <em>Disabled</em>, to prevent comments. Comment display settings and other controls may also be customized for each content type (some display settings are customizable by individual users).', array('@content-type' => url('admin/content/types'))) .'</p>';
      $output .= '<p>'. t('Comment permissions are assigned to user roles, and are used to determine whether anonymous users (or other roles) are allowed to comment on posts. If anonymous users are allowed to comment, their individual contact information may be retained in cookies stored on their local computer for use in later comment submissions. When a comment has no replies, it may be (optionally) edited by its author. The comment module uses the same input formats and HTML tags available when creating other forms of content.') .'</p>';
      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@comment">Comment module</a>.', array('@comment' => 'http://drupal.org/handbook/modules/comment/')) .'</p>';
      return $output;
    case 'admin/content/comment':
      return '<p>'. t("Below is a list of the latest comments posted to your site. Click on a subject to see the comment, the author's name to edit the author's user information, 'edit' to modify the text, and 'delete' to remove their submission.") .'</p>';
    case 'admin/content/comment/approval':
      return '<p>'. t("Below is a list of the comments posted to your site that need approval. To approve a comment, click on 'edit' and then change its 'moderation status' to Approved. Click on a subject to see the comment, the author's name to edit the author's user information, 'edit' to modify the text, and 'delete' to remove their submission.") .'</p>';
  }
}

/**
 * Implementation of hook_theme().
 */
function comment_theme() {
  return array(
    'comment_block' => array(
      'arguments' => array(),
    ),
    'comment_admin_overview' => array(
      'arguments' => array('form' => NULL),
    ),
    'comment_preview' => array(
      'arguments' => array('comment' => NULL, 'node' => NULL, 'links' => array(), 'visible' => 1),
    ),
    'comment_view' => array(
      'arguments' => array('comment' => NULL, 'node' => NULL, 'links' => array(), 'visible' => 1),
    ),
    'comment_controls' => array(
      'arguments' => array('form' => NULL),
    ),
    'comment' => array(
      'template' => 'comment',
      'arguments' => array('comment' => NULL, 'node' => NULL, 'links' => array()),
    ),
    'comment_folded' => array(
      'template' => 'comment-folded',
      'arguments' => array('comment' => NULL),
    ),
    'comment_flat_collapsed' => array(
      'arguments' => array('comment' => NULL, 'node' => NULL),
    ),
    'comment_flat_expanded' => array(
      'arguments' => array('comment' => NULL, 'node' => NULL),
    ),
    'comment_thread_collapsed' => array(
      'arguments' => array('comment' => NULL, 'node' => NULL),
    ),
    'comment_thread_expanded' => array(
      'arguments' => array('comment' => NULL, 'node' => NULL),
    ),
    'comment_post_forbidden' => array(
      'arguments' => array('nid' => NULL),
    ),
    'comment_wrapper' => array(
      'template' => 'comment-wrapper',
      'arguments' => array('content' => NULL, 'node' => NULL),
    ),
    'comment_submitted' => array(
      'arguments' => array('comment' => NULL),
    ),
  );
}

/**
 * Implementation of hook_menu().
 */
function comment_menu() {
  $items['admin/content/comment'] = array(
    'title' => 'Comments',
    'description' => 'List and edit site comments and the comment moderation queue.',
    'page callback' => 'comment_admin',
    'access arguments' => array('administer comments'),
    'file' => 'comment.admin.inc',
  );

  // Tabs:
  $items['admin/content/comment/new'] = array(
    'title' => 'Published comments',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items['admin/content/comment/approval'] = array(
    'title' => 'Approval queue',
    'page arguments' => array('approval'),
    'access arguments' => array('administer comments'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'comment.admin.inc',
  );

  $items['comment/delete'] = array(
    'title' => 'Delete comment',
    'page callback' => 'comment_delete',
    'access arguments' => array('administer comments'),
    'type' => MENU_CALLBACK,
    'file' => 'comment.admin.inc',
  );

  $items['comment/edit'] = array(
    'title' => 'Edit comment',
    'page callback' => 'comment_edit',
    'access arguments' => array('post comments'),
    'type' => MENU_CALLBACK,
    'file' => 'comment.pages.inc',
  );
  $items['comment/reply/%node'] = array(
    'title' => 'Reply to comment',
    'page callback' => 'comment_reply',
    'page arguments' => array(2),
    'access callback' => 'node_access',
    'access arguments' => array('view', 2),
    'type' => MENU_CALLBACK,
    'file' => 'comment.pages.inc',
  );

  return $items;
}

/**
 * Implementation of hook_node_type().
 */
function comment_node_type($op, $info) {
  $settings = array(
    'comment',
    'comment_default_mode',
    'comment_default_order',
    'comment_default_per_page',
    'comment_controls',
    'comment_anonymous',
    'comment_subject_field',
    'comment_preview',
    'comment_form_location',
  );
  switch ($op) {
    case 'delete':
      foreach ($settings as $setting) {
        variable_del($setting .'_'. $info->type);
      }
      break;
  }
}

/**
 * Implementation of hook_perm().
 */
function comment_perm() {
  return array('access comments', 'post comments', 'administer comments', 'post comments without approval');
}

/**
 * Implementation of hook_block().
 *
 * Generates a block with the most recent comments.
 */
function comment_block($op = 'list', $delta = 0) {
  if ($op == 'list') {
    $blocks[0]['info'] = t('Recent comments');
    return $blocks;
  }
  else if ($op == 'view' && user_access('access comments')) {
    $block['subject'] = t('Recent comments');
    $block['content'] = theme('comment_block');
    return $block;
  }
}

/**
 * Find a number of recent comments. This is done in two steps.
 *   1. Find the n (specified by $number) nodes that have the most recent
 *      comments.  This is done by querying node_comment_statistics which has
 *      an index on last_comment_timestamp, and is thus a fast query.
 *   2. Loading the information from the comments table based on the nids found
 *      in step 1.
 *
 * @param $number
 *   (optional) The maximum number of comments to find.
 * @return
 *   An array of comment objects each containing a nid,
 *   subject, cid, and timestamp, or an empty array if there are no recent
 *   comments visible to the current user.
 */
function comment_get_recent($number = 10) {
  // Select the $number nodes (visible to the current user) with the most
  // recent comments. This is efficient due to the index on
  // last_comment_timestamp.
  $result = db_query_range(db_rewrite_sql("SELECT nc.nid FROM {node_comment_statistics} nc WHERE nc.comment_count > 0 ORDER BY nc.last_comment_timestamp DESC", 'nc'), 0, $number);

  $nids = array();
  while ($row = db_fetch_object($result)) {
    $nids[] = $row->nid;
  }

  $comments = array();
  if (!empty($nids)) {
    // From among the comments on the nodes selected in the first query,
    // find the $number most recent comments.
    $result = db_query_range('SELECT c.nid, c.subject, c.cid, c.timestamp FROM {comments} c INNER JOIN {node} n ON n.nid = c.nid WHERE c.nid IN ('. implode(',', $nids) .') AND n.status = 1 AND c.status = %d ORDER BY c.cid DESC', COMMENT_PUBLISHED, 0, $number);
    while ($comment = db_fetch_object($result)) {
      $comments[] = $comment;
    }
  }

  return $comments;
}

/**
 * Calculate page number for first new comment.
 *
 * @param $num_comments
 *   Number of comments.
 * @param $new_replies
 *   Number of new replies.
 * @param $node
 *   The first new comment node.
 * @return
 *   "page=X" if the page number is greater than zero; empty string otherwise.
 */
function comment_new_page_count($num_comments, $new_replies, $node) {
  $comments_per_page = _comment_get_display_setting('comments_per_page', $node);
  $mode = _comment_get_display_setting('mode', $node);
  $order = _comment_get_display_setting('sort', $node);
  $pagenum = NULL;
  $flat = in_array($mode, array(COMMENT_MODE_FLAT_COLLAPSED, COMMENT_MODE_FLAT_EXPANDED));
  if ($num_comments <= $comments_per_page || ($flat && $order == COMMENT_ORDER_NEWEST_FIRST)) {
    // Only one page of comments or flat forum and newest first.
    // First new comment will always be on first page.
    $pageno = 0;
  }
  else {
    if ($flat) {
      // Flat comments and oldest first.
      $count = $num_comments - $new_replies;
    }
    else {
      // Threaded comments. See the documentation for comment_render().
      if ($order == COMMENT_ORDER_NEWEST_FIRST) {
        // Newest first: find the last thread with new comment
        $result = db_query('SELECT thread FROM (SELECT thread FROM {comments} WHERE nid = %d AND status = 0 ORDER BY timestamp DESC LIMIT %d) AS thread ORDER BY thread DESC LIMIT 1', $node->nid, $new_replies);
        $thread = db_result($result);
        $result_count = db_query("SELECT COUNT(*) FROM {comments} WHERE nid = %d AND status = 0 AND thread > '". $thread ."'", $node->nid);
      }
      else {
        // Oldest first: find the first thread with new comment
        $result = db_query('SELECT thread FROM (SELECT thread FROM {comments} WHERE nid = %d AND status = 0 ORDER BY timestamp DESC LIMIT %d) AS thread ORDER BY SUBSTRING(thread, 1, (LENGTH(thread) - 1)) LIMIT 1', $node->nid, $new_replies);
        $thread = substr(db_result($result), 0, -1);
        $result_count = db_query("SELECT COUNT(*) FROM {comments} WHERE nid = %d AND status = 0 AND SUBSTRING(thread, 1, (LENGTH(thread) - 1)) < '". $thread ."'", $node->nid);
      }
      $count = db_result($result_count);
    }
    $pageno =  $count / $comments_per_page;
  }
  if ($pageno >= 1) {
    $pagenum = "page=". intval($pageno);
  }
  return $pagenum;
}

/**
 * Returns a formatted list of recent comments to be displayed in the comment block.
 *
 * @return
 *   The comment list HTML.
 * @ingroup themeable
 */
function theme_comment_block() {
  $items = array();
  foreach (comment_get_recent() as $comment) {
    $items[] = l($comment->subject, 'node/'. $comment->nid, array('fragment' => 'comment-'. $comment->cid)) .'<br />'. t('@time ago', array('@time' => format_interval(time() - $comment->timestamp)));
  }
  if ($items) {
    return theme('item_list', $items);
  }
}

/**
 * Implementation of hook_link().
 */
function comment_link($type, $node = NULL, $teaser = FALSE) {
  $links = array();

  if ($type == 'node' && $node->comment) {

    if ($teaser) {
      // Main page: display the number of comments that have been posted.

      if (user_access('access comments')) {
        $all = comment_num_all($node->nid);

        if ($all) {
          $links['comment_comments'] = array(
            'title' => format_plural($all, '1 comment', '@count comments'),
            'href' => "node/$node->nid",
            'attributes' => array('title' => t('Jump to the first comment of this posting.')),
            'fragment' => 'comments'
          );

          $new = comment_num_new($node->nid);

          if ($new) {
            $links['comment_new_comments'] = array(
              'title' => format_plural($new, '1 new comment', '@count new comments'),
              'href' => "node/$node->nid",
              'query' => comment_new_page_count($all, $new, $node),
              'attributes' => array('title' => t('Jump to the first new comment of this posting.')),
              'fragment' => 'new'
            );
          }
        }
        else {
          if ($node->comment == COMMENT_NODE_READ_WRITE) {
            if (user_access('post comments')) {
              $links['comment_add'] = array(
                'title' => t('Add new comment'),
                'href' => "comment/reply/$node->nid",
                'attributes' => array('title' => t('Add a new comment to this page.')),
                'fragment' => 'comment-form'
              );
            }
            else {
              $links['comment_forbidden']['title'] = theme('comment_post_forbidden', $node);
            }
          }
        }
      }
    }
    else {
      // Node page: add a "post comment" link if the user is allowed to
      // post comments, if this node is not read-only, and if the comment form isn't already shown

      if ($node->comment == COMMENT_NODE_READ_WRITE) {
        if (user_access('post comments')) {
          if (variable_get('comment_form_location_'. $node->type, COMMENT_FORM_SEPARATE_PAGE) == COMMENT_FORM_SEPARATE_PAGE) {
            $links['comment_add'] = array(
              'title' => t('Add new comment'),
              'href' => "comment/reply/$node->nid",
              'attributes' => array('title' => t('Share your thoughts and opinions related to this posting.')),
              'fragment' => 'comment-form'
            );
          }
        }
        else {
          $links['comment_forbidden']['title'] = theme('comment_post_forbidden', $node);
        }
      }
    }
  }

  if ($type == 'comment') {
    $links = comment_links($node, $teaser);
  }
  if (isset($links['comment_forbidden'])) {
    $links['comment_forbidden']['html'] = TRUE;
  }

  return $links;
}

/**
 * Implementation of hook_form_alter().
 */
function comment_form_alter(&$form, $form_state, $form_id) {
  if ($form_id == 'node_type_form' && isset($form['identity']['type'])) {
    $form['comment'] = array(
      '#type' => 'fieldset',
      '#title' => t('Comment settings'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
    );
    $form['comment']['comment'] = array(
      '#type' => 'radios',
      '#title' => t('Default comment setting'),
      '#default_value' => variable_get('comment_'. $form['#node_type']->type, COMMENT_NODE_READ_WRITE),
      '#options' => array(t('Disabled'), t('Read only'), t('Read/Write')),
      '#description' => t('Users with the <em>administer comments</em> permission will be able to override this setting.'),
    );
    $form['comment']['comment_default_mode'] = array(
      '#type' => 'radios',
      '#title' => t('Default display mode'),
      '#default_value' => variable_get('comment_default_mode_'. $form['#node_type']->type, COMMENT_MODE_THREADED_EXPANDED),
      '#options' => _comment_get_modes(),
      '#description' => t('The default view for comments. Expanded views display the body of the comment. Threaded views keep replies together.'),
    );
    $form['comment']['comment_default_order'] = array(
      '#type' => 'radios',
      '#title' => t('Default display order'),
      '#default_value' => variable_get('comment_default_order_'. $form['#node_type']->type, COMMENT_ORDER_NEWEST_FIRST),
      '#options' => _comment_get_orders(),
      '#description' => t('The default sorting for new users and anonymous users while viewing comments. These users may change their view using the comment control panel. For registered users, this change is remembered as a persistent user preference.'),
    );
    $form['comment']['comment_default_per_page'] = array(
      '#type' => 'select',
      '#title' => t('Default comments per page'),
      '#default_value' => variable_get('comment_default_per_page_'. $form['#node_type']->type, 50),
      '#options' => _comment_per_page(),
      '#description' => t('Default number of comments for each page: more comments are distributed in several pages.'),
    );
    $form['comment']['comment_controls'] = array(
      '#type' => 'radios',
      '#title' => t('Comment controls'),
      '#default_value' => variable_get('comment_controls_'. $form['#node_type']->type, COMMENT_CONTROLS_HIDDEN),
      '#options' => array(
        t('Display above the comments'),
        t('Display below the comments'),
        t('Display above and below the comments'),
        t('Do not display')),
      '#description' => t('Position of the comment controls box. The comment controls let the user change the default display mode and display order of comments.'),
    );
    $form['comment']['comment_anonymous'] = array(
      '#type' => 'radios',
      '#title' => t('Anonymous commenting'),
      '#default_value' => variable_get('comment_anonymous_'. $form['#node_type']->type, COMMENT_ANONYMOUS_MAYNOT_CONTACT),
      '#options' => array(
        COMMENT_ANONYMOUS_MAYNOT_CONTACT => t('Anonymous posters may not enter their contact information'),
        COMMENT_ANONYMOUS_MAY_CONTACT => t('Anonymous posters may leave their contact information'),
        COMMENT_ANONYMOUS_MUST_CONTACT => t('Anonymous posters must leave their contact information')),
      '#description' => t('This option is enabled when anonymous users have permission to post comments on the <a href="@url">permissions page</a>.', array('@url' => url('admin/user/permissions', array('fragment' => 'module-comment')))),
    );
    if (!user_access('post comments', drupal_anonymous_user())) {
      $form['comment']['comment_anonymous']['#disabled'] = TRUE;
    }
    $form['comment']['comment_subject_field'] = array(
      '#type' => 'radios',
      '#title' => t('Comment subject field'),
      '#default_value' => variable_get('comment_subject_field_'. $form['#node_type']->type, 1),
      '#options' => array(t('Disabled'), t('Enabled')),
      '#description' => t('Can users provide a unique subject for their comments?'),
    );
    $form['comment']['comment_preview'] = array(
      '#type' => 'radios',
      '#title' => t('Preview comment'),
      '#default_value' => variable_get('comment_preview_'. $form['#node_type']->type, COMMENT_PREVIEW_REQUIRED),
      '#options' => array(t('Optional'), t('Required')),
      '#description' => t("Forces a user to look at their comment by clicking on a 'Preview' button before they can actually add the comment"),
    );
    $form['comment']['comment_form_location'] = array(
      '#type' => 'radios',
      '#title' => t('Location of comment submission form'),
      '#default_value' => variable_get('comment_form_location_'. $form['#node_type']->type, COMMENT_FORM_SEPARATE_PAGE),
      '#options' => array(t('Display on separate page'), t('Display below post or comments')),
    );
  }
  elseif (isset($form['type']) && isset($form['#node'])) {
    if ($form['type']['#value'] .'_node_form' == $form_id) {
      $node = $form['#node'];
      $form['comment_settings'] = array(
        '#type' => 'fieldset',
        '#access' => user_access('administer comments'),
        '#title' => t('Comment settings'),
        '#collapsible' => TRUE,
        '#collapsed' => TRUE,
        '#weight' => 30,
      );
      $form['comment_settings']['comment'] = array(
        '#type' => 'radios',
        '#parents' => array('comment'),
        '#default_value' => $node->comment,
        '#options' => array(t('Disabled'), t('Read only'), t('Read/Write')),
      );
    }
  }
}

/**
 * Implementation of hook_nodeapi().
 */
function comment_nodeapi(&$node, $op, $arg = 0) {
  switch ($op) {
    case 'load':
      return db_fetch_array(db_query("SELECT last_comment_timestamp, last_comment_name, comment_count FROM {node_comment_statistics} WHERE nid = %d", $node->nid));
      break;

    case 'prepare':
      if (!isset($node->comment)) {
        $node->comment = variable_get("comment_$node->type", COMMENT_NODE_READ_WRITE);
      }
      break;

    case 'insert':
      db_query('INSERT INTO {node_comment_statistics} (nid, last_comment_timestamp, last_comment_name, last_comment_uid, comment_count) VALUES (%d, %d, NULL, %d, 0)', $node->nid, $node->changed, $node->uid);
      break;

    case 'delete':
      db_query('DELETE FROM {comments} WHERE nid = %d', $node->nid);
      db_query('DELETE FROM {node_comment_statistics} WHERE nid = %d', $node->nid);
      break;

    case 'update index':
      $text = '';
      $comments = db_query('SELECT subject, comment, format FROM {comments} WHERE nid = %d AND status = %d', $node->nid, COMMENT_PUBLISHED);
      while ($comment = db_fetch_object($comments)) {
        $text .= '<h2>'. check_plain($comment->subject) .'</h2>'. check_markup($comment->comment, $comment->format, FALSE);
      }
      return $text;

    case 'search result':
      $comments = db_result(db_query('SELECT comment_count FROM {node_comment_statistics} WHERE nid = %d', $node->nid));
      return format_plural($comments, '1 comment', '@count comments');

    case 'rss item':
      if ($node->comment != COMMENT_NODE_DISABLED) {
        return array(array('key' => 'comments', 'value' => url('node/'. $node->nid, array('fragment' => 'comments', 'absolute' => TRUE))));
      }
      else {
        return array();
      }
  }
}

/**
 * Implementation of hook_user().
 */
function comment_user($type, $edit, &$user, $category = NULL) {
  if ($type == 'delete') {
    db_query('UPDATE {comments} SET uid = 0 WHERE uid = %d', $user->uid);
    db_query('UPDATE {node_comment_statistics} SET last_comment_uid = 0 WHERE last_comment_uid = %d', $user->uid);
  }
}

/**
 * This is *not* a hook_access() implementation. This function is called
 * to determine whether the current user has access to a particular comment.
 *
 * Authenticated users can edit their comments as long they have not been
 * replied to. This prevents people from changing or revising their
 * statements based on the replies to their posts.
 *
 * @param $op
 *   The operation that is to be performed on the comment. Only 'edit' is recognized now.
 * @param $comment
 *   The comment object.
 * @return
 *   TRUE if the current user has acces to the comment, FALSE otherwise.
 */
function comment_access($op, $comment) {
  global $user;

  if ($op == 'edit') {
    return ($user->uid && $user->uid == $comment->uid && comment_num_replies($comment->cid) == 0 && $comment->status == COMMENT_PUBLISHED) || user_access('administer comments');
  }
}

/**
 * A simple helper function.
 *
 * @return
 *   The 0th and the 1st path components joined by a slash.
 */
function comment_node_url() {
  return arg(0) .'/'. arg(1);
}

/**
 * Accepts a submission of new or changed comment content.
 *
 * @param $edit
 *   A comment array.
 *
 * @return
 *   If the comment is successfully saved the comment ID is returned. If the comment
 *   is not saved, FALSE is returned.
 */
function comment_save($edit) {
  global $user;
  if (user_access('post comments') && (user_access('administer comments') || node_comment_mode($edit['nid']) == COMMENT_NODE_READ_WRITE)) {
    if (!form_get_errors()) {
      $edit += array(
        'mail' => '',
        'homepage' => '',
        'name' => '',
        'status' => user_access('post comments without approval') ? COMMENT_PUBLISHED : COMMENT_NOT_PUBLISHED,
      );
      if ($edit['cid']) {
        // Update the comment in the database.
        db_query("UPDATE {comments} SET status = %d, timestamp = %d, subject = '%s', comment = '%s', format = %d, uid = %d, name = '%s', mail = '%s', homepage = '%s' WHERE cid = %d", $edit['status'], $edit['timestamp'], $edit['subject'], $edit['comment'], $edit['format'], $edit['uid'], $edit['name'], $edit['mail'], $edit['homepage'], $edit['cid']);

        // Allow modules to respond to the updating of a comment.
        comment_invoke_comment($edit, 'update');

        // Add an entry to the watchdog log.
        watchdog('content', 'Comment: updated %subject.', array('%subject' => $edit['subject']), WATCHDOG_NOTICE, l(t('view'), 'node/'. $edit['nid'], array('fragment' => 'comment-'. $edit['cid'])));
      }
      else {
        // Add the comment to database.
        // Here we are building the thread field. See the documentation for
        // comment_render().
        if ($edit['pid'] == 0) {
          // This is a comment with no parent comment (depth 0): we start
          // by retrieving the maximum thread level.
          $max = db_result(db_query('SELECT MAX(thread) FROM {comments} WHERE nid = %d', $edit['nid']));

          // Strip the "/" from the end of the thread.
          $max = rtrim($max, '/');

          // Finally, build the thread field for this new comment.
          $thread = int2vancode(vancode2int($max) + 1) .'/';
        }
        else {
          // This is comment with a parent comment: we increase
          // the part of the thread value at the proper depth.

          // Get the parent comment:
          $parent = _comment_load($edit['pid']);

          // Strip the "/" from the end of the parent thread.
          $parent->thread = (string) rtrim((string) $parent->thread, '/');

          // Get the max value in _this_ thread.
          $max = db_result(db_query("SELECT MAX(thread) FROM {comments} WHERE thread LIKE '%s.%%' AND nid = %d", $parent->thread, $edit['nid']));

          if ($max == '') {
            // First child of this parent.
            $thread = $parent->thread .'.'. int2vancode(0) .'/';
          }
          else {
            // Strip the "/" at the end of the thread.
            $max = rtrim($max, '/');

            // We need to get the value at the correct depth.
            $parts = explode('.', $max);
            $parent_depth = count(explode('.', $parent->thread));
            $last = $parts[$parent_depth];

            // Finally, build the thread field for this new comment.
            $thread = $parent->thread .'.'. int2vancode(vancode2int($last) + 1) .'/';
          }
        }

        if (empty($edit['timestamp'])) {
          $edit['timestamp'] = time();
        }

        if ($edit['uid'] === $user->uid && isset($user->name)) { // '===' Need to modify anonymous users as well.
          $edit['name'] = $user->name;
        }

        db_query("INSERT INTO {comments} (nid, pid, uid, subject, comment, format, hostname, timestamp, status, thread, name, mail, homepage) VALUES (%d, %d, %d, '%s', '%s', %d, '%s', %d, %d, '%s', '%s', '%s', '%s')", $edit['nid'], $edit['pid'], $edit['uid'], $edit['subject'], $edit['comment'], $edit['format'], ip_address(), $edit['timestamp'], $edit['status'], $thread, $edit['name'], $edit['mail'], $edit['homepage']);
        $edit['cid'] = db_last_insert_id('comments', 'cid');

        // Tell the other modules a new comment has been submitted.
        comment_invoke_comment($edit, 'insert');

        // Add an entry to the watchdog log.
        watchdog('content', 'Comment: added %subject.', array('%subject' => $edit['subject']), WATCHDOG_NOTICE, l(t('view'), 'node/'. $edit['nid'], array('fragment' => 'comment-'. $edit['cid'])));
      }
      _comment_update_node_statistics($edit['nid']);

      // Clear the cache so an anonymous user can see his comment being added.
      cache_clear_all();

      // Ignore slave server temporarily to give time for the
      // saved comment to be propagated to the slave.
      db_ignore_slave();

      // Explain the approval queue if necessary, and then
      // redirect the user to the node he's commenting on.
      if ($edit['status'] == COMMENT_NOT_PUBLISHED) {
        drupal_set_message(t('Your comment has been queued for moderation by site administrators and will be published after approval.'));
      }
      else {
        comment_invoke_comment($edit, 'publish');
      }
      return $edit['cid'];
    }
    else {
      return FALSE;
    }
  }
  else {
    watchdog('content', 'Comment: unauthorized comment submitted or comment submitted to a closed post %subject.', array('%subject' => $edit['subject']), WATCHDOG_WARNING);
    drupal_set_message(t('Comment: unauthorized comment submitted or comment submitted to a closed post %subject.', array('%subject' => $edit['subject'])), 'error');
    return FALSE;
  }
}

/**
 * Build command links for a comment (e.g.\ edit, reply, delete) with respect to the current user's access permissions.
 *
 * @param $comment
 *   The comment to which the links will be related.
 * @param $return
 *   Not used.
 * @return
 *   An associative array containing the links.
 */
function comment_links($comment, $return = 1) {
  global $user;

  $links = array();

  // If we are viewing just this comment, we link back to the node.
  if ($return) {
    $links['comment_parent'] = array(
      'title' => t('parent'),
      'href' => comment_node_url(),
      'fragment' => "comment-$comment->cid"
    );
  }

  if (node_comment_mode($comment->nid) == COMMENT_NODE_READ_WRITE) {
    if (user_access('administer comments') && user_access('post comments')) {
      $links['comment_delete'] = array(
        'title' => t('delete'),
        'href' => "comment/delete/$comment->cid"
      );
      $links['comment_edit'] = array(
        'title' => t('edit'),
        'href' => "comment/edit/$comment->cid"
      );
      $links['comment_reply'] = array(
        'title' => t('reply'),
        'href' => "comment/reply/$comment->nid/$comment->cid"
      );
    }
    else if (user_access('post comments')) {
      if (comment_access('edit', $comment)) {
        $links['comment_edit'] = array(
          'title' => t('edit'),
          'href' => "comment/edit/$comment->cid"
        );
      }
      $links['comment_reply'] = array(
        'title' => t('reply'),
        'href' => "comment/reply/$comment->nid/$comment->cid"
      );
    }
    else {
      $node = node_load($comment->nid);
      $links['comment_forbidden']['title'] = theme('comment_post_forbidden', $node);
    }
  }

  return $links;
}

/**
 * Renders comment(s).
 *
 * @param $node
 *   The node which comment(s) needs rendering.
 * @param $cid
 *   Optional, if given, only one comment is rendered.
 *
 * To display threaded comments in the correct order we keep a 'thread' field
 * and order by that value. This field keeps this data in
 * a way which is easy to update and convenient to use.
 *
 * A "thread" value starts at "1". If we add a child (A) to this comment,
 * we assign it a "thread" = "1.1". A child of (A) will have "1.1.1". Next
 * brother of (A) will get "1.2". Next brother of the parent of (A) will get
 * "2" and so on.
 *
 * First of all note that the thread field stores the depth of the comment:
 * depth 0 will be "X", depth 1 "X.X", depth 2 "X.X.X", etc.
 *
 * Now to get the ordering right, consider this example:
 *
 * 1
 * 1.1
 * 1.1.1
 * 1.2
 * 2
 *
 * If we "ORDER BY thread ASC" we get the above result, and this is the
 * natural order sorted by time. However, if we "ORDER BY thread DESC"
 * we get:
 *
 * 2
 * 1.2
 * 1.1.1
 * 1.1
 * 1
 *
 * Clearly, this is not a natural way to see a thread, and users will get
 * confused. The natural order to show a thread by time desc would be:
 *
 * 2
 * 1
 * 1.2
 * 1.1
 * 1.1.1
 *
 * which is what we already did before the standard pager patch. To achieve
 * this we simply add a "/" at the end of each "thread" value. This way out
 * thread fields will look like depicted below:
 *
 * 1/
 * 1.1/
 * 1.1.1/
 * 1.2/
 * 2/
 *
 * we add "/" since this char is, in ASCII, higher than every number, so if
 * now we "ORDER BY thread DESC" we get the correct order. However this would
 * spoil the reverse ordering, "ORDER BY thread ASC" -- here, we do not need
 * to consider the trailing "/" so we use a substring only.
 */
function comment_render($node, $cid = 0) {
  global $user;

  $output = '';

  if (user_access('access comments')) {
    // Pre-process variables.
    $nid = $node->nid;
    if (empty($nid)) {
      $nid = 0;
    }

    $mode = _comment_get_display_setting('mode', $node);
    $order = _comment_get_display_setting('sort', $node);
    $comments_per_page = _comment_get_display_setting('comments_per_page', $node);

    if ($cid && is_numeric($cid)) {
      // Single comment view.
      $query = 'SELECT c.cid, c.pid, c.nid, c.subject, c.comment, c.format, c.timestamp, c.name, c.mail, c.homepage, u.uid, u.name AS registered_name, u.signature, u.signature_format, u.picture, u.data, c.status FROM {comments} c INNER JOIN {users} u ON c.uid = u.uid WHERE c.cid = %d';
      $query_args = array($cid);
      if (!user_access('administer comments')) {
        $query .= ' AND c.status = %d';
        $query_args[] = COMMENT_PUBLISHED;
      }

      $query = db_rewrite_sql($query, 'c', 'cid');
      $result = db_query($query, $query_args);

      if ($comment = db_fetch_object($result)) {
        $comment->name = $comment->uid ? $comment->registered_name : $comment->name;
        $links = module_invoke_all('link', 'comment', $comment, 1);
        drupal_alter('link', $links, $node, $comment);

        $output .= theme('comment_view', $comment, $node, $links);
      }
    }
    else {
      // Multiple comment view
      $query_count = 'SELECT COUNT(*) FROM {comments} c WHERE c.nid = %d';
      $query = 'SELECT c.cid as cid, c.pid, c.nid, c.subject, c.comment, c.format, c.timestamp, c.name, c.mail, c.homepage, u.uid, u.name AS registered_name, u.signature, u.signature_format, u.picture, u.data, c.thread, c.status FROM {comments} c INNER JOIN {users} u ON c.uid = u.uid WHERE c.nid = %d';

      $query_args = array($nid);
      if (!user_access('administer comments')) {
        $query .= ' AND c.status = %d';
        $query_count .= ' AND c.status = %d';
        $query_args[] = COMMENT_PUBLISHED;
      }

      if ($order == COMMENT_ORDER_NEWEST_FIRST) {
        if ($mode == COMMENT_MODE_FLAT_COLLAPSED || $mode == COMMENT_MODE_FLAT_EXPANDED) {
          $query .= ' ORDER BY c.cid DESC';
        }
        else {
          $query .= ' ORDER BY c.thread DESC';
        }
      }
      else if ($order == COMMENT_ORDER_OLDEST_FIRST) {
        if ($mode == COMMENT_MODE_FLAT_COLLAPSED || $mode == COMMENT_MODE_FLAT_EXPANDED) {
          $query .= ' ORDER BY c.cid';
        }
        else {
          // See comment above. Analysis reveals that this doesn't cost too
          // much. It scales much much better than having the whole comment
          // structure.
          $query .= ' ORDER BY SUBSTRING(c.thread, 1, (LENGTH(c.thread) - 1))';
        }
      }
      $query = db_rewrite_sql($query, 'c', 'cid');
      $query_count = db_rewrite_sql($query_count, 'c', 'cid');

      // Start a form, for use with comment control.
      $result = pager_query($query, $comments_per_page, 0, $query_count, $query_args);

      $divs = 0;
      $num_rows = FALSE;
      $comments = '';
      drupal_add_css(drupal_get_path('module', 'comment') .'/comment.css');
      while ($comment = db_fetch_object($result)) {
        $comment = drupal_unpack($comment);
        $comment->name = $comment->uid ? $comment->registered_name : $comment->name;
        $comment->depth = count(explode('.', $comment->thread)) - 1;

        if ($mode == COMMENT_MODE_THREADED_COLLAPSED || $mode == COMMENT_MODE_THREADED_EXPANDED) {
          if ($comment->depth > $divs) {
            $divs++;
            $comments .= '<div class="indented">';
          }
          else {
            while ($comment->depth < $divs) {
              $divs--;
              $comments .= '</div>';
            }
          }
        }

        if ($mode == COMMENT_MODE_FLAT_COLLAPSED) {
          $comments .= theme('comment_flat_collapsed', $comment, $node);
        }
        else if ($mode == COMMENT_MODE_FLAT_EXPANDED) {
          $comments .= theme('comment_flat_expanded', $comment, $node);
        }
        else if ($mode == COMMENT_MODE_THREADED_COLLAPSED) {
          $comments .= theme('comment_thread_collapsed', $comment, $node);
        }
        else if ($mode == COMMENT_MODE_THREADED_EXPANDED) {
          $comments .= theme('comment_thread_expanded', $comment, $node);
        }

        $num_rows = TRUE;
      }
      while ($divs-- > 0) {
        $comments .= '</div>';
      }

      $comment_controls = variable_get('comment_controls_'. $node->type, COMMENT_CONTROLS_HIDDEN);
      if ($num_rows && ($comment_controls == COMMENT_CONTROLS_ABOVE || $comment_controls == COMMENT_CONTROLS_ABOVE_BELOW)) {
        $output .= drupal_get_form('comment_controls', $mode, $order, $comments_per_page);
      }

      $output .= $comments;
      $output .= theme('pager', NULL, $comments_per_page, 0);

      if ($num_rows && ($comment_controls == COMMENT_CONTROLS_BELOW || $comment_controls == COMMENT_CONTROLS_ABOVE_BELOW)) {
        $output .= drupal_get_form('comment_controls', $mode, $order, $comments_per_page);
      }
    }

    // If enabled, show new comment form if it's not already being displayed.
    $reply = arg(0) == 'comment' && arg(1) == 'reply';
    if (user_access('post comments') && node_comment_mode($nid) == COMMENT_NODE_READ_WRITE && (variable_get('comment_form_location_'. $node->type, COMMENT_FORM_SEPARATE_PAGE) == COMMENT_FORM_BELOW) && !$reply) {
      $output .= comment_form_box(array('nid' => $nid), t('Post new comment'));
    }

    if ($output) {
      $output = theme('comment_wrapper', $output, $node);
    }
  }

  return $output;
}

/**
 * Comment operations. We offer different update operations depending on
 * which comment administration page we're on.
 *
 * @param $action
 *   The comment administration page.
 * @return
 *   An associative array containing the offered operations.
 */
function comment_operations($action = NULL) {
  if ($action == 'publish') {
    $operations = array(
      'publish' => array(t('Publish the selected comments'), 'UPDATE {comments} SET status = '. COMMENT_PUBLISHED .' WHERE cid = %d'),
      'delete' => array(t('Delete the selected comments'), ''),
    );
  }
  else if ($action == 'unpublish') {
    $operations = array(
      'unpublish' => array(t('Unpublish the selected comments'), 'UPDATE {comments} SET status = '. COMMENT_NOT_PUBLISHED .' WHERE cid = %d'),
      'delete' => array(t('Delete the selected comments'), ''),
    );
  }
  else {
    $operations = array(
      'publish' => array(t('Publish the selected comments'), 'UPDATE {comments} SET status = '. COMMENT_PUBLISHED .' WHERE cid = %d'),
      'unpublish' => array(t('Unpublish the selected comments'), 'UPDATE {comments} SET status = '. COMMENT_NOT_PUBLISHED .' WHERE cid = %d'),
      'delete' => array(t('Delete the selected comments'), ''),
    );
  }
  return $operations;
}

/**
 * Misc functions: helpers, privates, history
 */

/**
 * Load the entire comment by cid.
 *
 * @param $cid
 *   The identifying comment id.
 * @return
 *   The comment object.
 */
function _comment_load($cid) {
  return db_fetch_object(db_query('SELECT * FROM {comments} WHERE cid = %d', $cid));
}

/**
 * Get comment count for a node.
 *
 * @param $nid
 *   The node id.
 * @return
 *   The comment count.
 */
function comment_num_all($nid) {
  static $cache;

  if (!isset($cache[$nid])) {
    $cache[$nid] = db_result(db_query('SELECT comment_count FROM {node_comment_statistics} WHERE nid = %d', $nid));
  }
  return $cache[$nid];
}

/**
 * Get replies count for a comment.
 *
 * @param $pid
 *   The comment id.
 * @return
 *   The replies count.
 */
function comment_num_replies($pid) {
  static $cache;

  if (!isset($cache[$pid])) {
    $cache[$pid] = db_result(db_query('SELECT COUNT(cid) FROM {comments} WHERE pid = %d AND status = %d', $pid, COMMENT_PUBLISHED));
  }

  return $cache[$pid];
}

/**
 * Get number of new comments for current user and specified node.
 *
 * @param $nid
 *   node-id to count comments for
 * @param $timestamp
 *   time to count from (defaults to time of last user access
 *   to node)
 */
function comment_num_new($nid, $timestamp = 0) {
  global $user;

  if ($user->uid) {
    // Retrieve the timestamp at which the current user last viewed the
    // specified node.
    if (!$timestamp) {
      $timestamp = node_last_viewed($nid);
    }
    $timestamp = ($timestamp > NODE_NEW_LIMIT ? $timestamp : NODE_NEW_LIMIT);

    // Use the timestamp to retrieve the number of new comments.
    $result = db_result(db_query('SELECT COUNT(c.cid) FROM {node} n INNER JOIN {comments} c ON n.nid = c.nid WHERE n.nid = %d AND timestamp > %d AND c.status = %d', $nid, $timestamp, COMMENT_PUBLISHED));

    return $result;
  }
  else {
    return 0;
  }

}

/**
 * Validate comment data.
 *
 * @param $edit
 *   An associative array containig the comment data.
 * @return
 *   The original $edit.
 */
function comment_validate($edit) {
  global $user;

  // Invoke other validation handlers
  comment_invoke_comment($edit, 'validate');

  if (isset($edit['date'])) {
    // As of PHP 5.1.0, strtotime returns FALSE upon failure instead of -1.
    if (strtotime($edit['date']) <= 0) {
      form_set_error('date', t('You have to specify a valid date.'));
    }
  }
  if (isset($edit['author']) && !$account = user_load(array('name' => $edit['author']))) {
    form_set_error('author', t('You have to specify a valid author.'));
  }

  // Check validity of name, mail and homepage (if given)
  if (!$user->uid || isset($edit['is_anonymous'])) {
    $node = node_load($edit['nid']);
    if (variable_get('comment_anonymous_'. $node->type, COMMENT_ANONYMOUS_MAYNOT_CONTACT) > COMMENT_ANONYMOUS_MAYNOT_CONTACT) {
      if ($edit['name']) {
        $taken = db_result(db_query("SELECT COUNT(uid) FROM {users} WHERE name = '%s'", $edit['name']));

        if ($taken != 0) {
          form_set_error('name', t('The name you used belongs to a registered user.'));
        }

      }
      else if (variable_get('comment_anonymous_'. $node->type, COMMENT_ANONYMOUS_MAYNOT_CONTACT) == COMMENT_ANONYMOUS_MUST_CONTACT) {
        form_set_error('name', t('You have to leave your name.'));
      }

      if ($edit['mail']) {
        if (!valid_email_address($edit['mail'])) {
          form_set_error('mail', t('The e-mail address you specified is not valid.'));
        }
      }
      else if (variable_get('comment_anonymous_'. $node->type, COMMENT_ANONYMOUS_MAYNOT_CONTACT) == COMMENT_ANONYMOUS_MUST_CONTACT) {
        form_set_error('mail', t('You have to leave an e-mail address.'));
      }

      if ($edit['homepage']) {
        if (!valid_url($edit['homepage'], TRUE)) {
          form_set_error('homepage', t('The URL of your homepage is not valid. Remember that it must be fully qualified, i.e. of the form <code>http://example.com/directory</code>.'));
        }
      }
    }
  }

  return $edit;
}

/**
 * Generate the basic commenting form, for appending to a node or display on a separate page.
 *
 * @param $title
 *   Not used.
 * @ingroup forms
 * @see comment_form_validate()
 * @see comment_form_submit()
 */
function comment_form(&$form_state, $edit, $title = NULL) {
  global $user;

  $op = isset($_POST['op']) ? $_POST['op'] : '';
  $node = node_load($edit['nid']);

  if (!$user->uid && variable_get('comment_anonymous_'. $node->type, COMMENT_ANONYMOUS_MAYNOT_CONTACT) != COMMENT_ANONYMOUS_MAYNOT_CONTACT) {
    drupal_add_js(drupal_get_path('module', 'comment') .'/comment.js');
  }
  $edit += array('name' => '', 'mail' => '', 'homepage' => '');
  if ($user->uid) {
    if (!empty($edit['cid']) && user_access('administer comments')) {
      if (!empty($edit['author'])) {
        $author = $edit['author'];
      }
      elseif (!empty($edit['name'])) {
        $author = $edit['name'];
      }
      else {
        $author = $edit['registered_name'];
      }

      if (!empty($edit['status'])) {
        $status = $edit['status'];
      }
      else {
        $status = 0;
      }

      if (!empty($edit['date'])) {
        $date = $edit['date'];
      }
      else {
        $date = format_date($edit['timestamp'], 'custom', 'Y-m-d H:i O');
      }

      $form['admin'] = array(
        '#type' => 'fieldset',
        '#title' => t('Administration'),
        '#collapsible' => TRUE,
        '#collapsed' => TRUE,
        '#weight' => -2,
      );

      if ($edit['registered_name'] != '') {
        // The comment is by a registered user
        $form['admin']['author'] = array(
          '#type' => 'textfield',
          '#title' => t('Authored by'),
          '#size' => 30,
          '#maxlength' => 60,
          '#autocomplete_path' => 'user/autocomplete',
          '#default_value' => $author,
          '#weight' => -1,
        );
      }
      else {
        // The comment is by an anonymous user
        $form['is_anonymous'] = array(
          '#type' => 'value',
          '#value' => TRUE,
        );
        $form['admin']['name'] = array(
          '#type' => 'textfield',
          '#title' => t('Authored by'),
          '#size' => 30,
          '#maxlength' => 60,
          '#default_value' => $author,
          '#weight' => -1,
        );
        $form['admin']['mail'] = array(
          '#type' => 'textfield',
          '#title' => t('E-mail'),
          '#maxlength' => 64,
          '#size' => 30,
          '#default_value' => $edit['mail'],
          '#description' => t('The content of this field is kept private and will not be shown publicly.'),
        );

        $form['admin']['homepage'] = array(
          '#type' => 'textfield',
          '#title' => t('Homepage'),
          '#maxlength' => 255,
          '#size' => 30,
          '#default_value' => $edit['homepage'],
        );
      }

      $form['admin']['date'] = array('#type' => 'textfield', '#parents' => array('date'), '#title' => t('Authored on'), '#size' => 20, '#maxlength' => 25, '#default_value' => $date, '#weight' => -1);

      $form['admin']['status'] = array('#type' => 'radios', '#parents' => array('status'), '#title' => t('Status'), '#default_value' =>  $status, '#options' => array(t('Published'), t('Not published')), '#weight' => -1);

    }
    else {
      $form['_author'] = array('#type' => 'item', '#title' => t('Your name'), '#value' => theme('username', $user)
      );
      $form['author'] = array('#type' => 'value', '#value' => $user->name);
    }
  }
  else if (variable_get('comment_anonymous_'. $node->type, COMMENT_ANONYMOUS_MAYNOT_CONTACT) == COMMENT_ANONYMOUS_MAY_CONTACT) {
    $form['name'] = array('#type' => 'textfield', '#title' => t('Your name'), '#maxlength' => 60, '#size' => 30, '#default_value' => $edit['name'] ? $edit['name'] : variable_get('anonymous', t('Anonymous'))
    );

    $form['mail'] = array('#type' => 'textfield', '#title' => t('E-mail'), '#maxlength' => 64, '#size' => 30, '#default_value' => $edit['mail'], '#description' => t('The content of this field is kept private and will not be shown publicly.')
    );

    $form['homepage'] = array('#type' => 'textfield', '#title' => t('Homepage'), '#maxlength' => 255, '#size' => 30, '#default_value' => $edit['homepage']);
  }
  else if (variable_get('comment_anonymous_'. $node->type, COMMENT_ANONYMOUS_MAYNOT_CONTACT) == COMMENT_ANONYMOUS_MUST_CONTACT) {
    $form['name'] = array('#type' => 'textfield', '#title' => t('Your name'), '#maxlength' => 60, '#size' => 30, '#default_value' => $edit['name'] ? $edit['name'] : variable_get('anonymous', t('Anonymous')), '#required' => TRUE);

    $form['mail'] = array('#type' => 'textfield', '#title' => t('E-mail'), '#maxlength' => 64, '#size' => 30, '#default_value' => $edit['mail'], '#description' => t('The content of this field is kept private and will not be shown publicly.'), '#required' => TRUE);

    $form['homepage'] = array('#type' => 'textfield', '#title' => t('Homepage'), '#maxlength' => 255, '#size' => 30, '#default_value' => $edit['homepage']);
  }

  if (variable_get('comment_subject_field_'. $node->type, 1) == 1) {
    $form['subject'] = array('#type' => 'textfield', '#title' => t('Subject'), '#maxlength' => 64, '#default_value' => !empty($edit['subject']) ? $edit['subject'] : '');
  }

  if (!empty($edit['comment'])) {
    $default = $edit['comment'];
  }
  else {
    $default = '';
  }

  $form['comment_filter']['comment'] = array(
    '#type' => 'textarea',
    '#title' => t('Comment'),
    '#rows' => 15,
    '#default_value' => $default,
    '#required' => TRUE,
  );
  if (!isset($edit['format'])) {
    $edit['format'] = FILTER_FORMAT_DEFAULT;
  }
  $form['comment_filter']['format'] = filter_form($edit['format']);

  $form['cid'] = array('#type' => 'value', '#value' => !empty($edit['cid']) ? $edit['cid'] : NULL);
  $form['pid'] = array('#type' => 'value', '#value' => !empty($edit['pid']) ? $edit['pid'] : NULL);
  $form['nid'] = array('#type' => 'value', '#value' => $edit['nid']);
  $form['uid'] = array('#type' => 'value', '#value' => !empty($edit['uid']) ? $edit['uid'] : 0);

  // Only show save button if preview is optional or if we are in preview mode.
  // We show the save button in preview mode even if there are form errors so that
  // optional form elements (e.g., captcha) can be updated in preview mode.
  if (!form_get_errors() && ((variable_get('comment_preview_'. $node->type, COMMENT_PREVIEW_REQUIRED) == COMMENT_PREVIEW_OPTIONAL) || ($op == t('Preview')) || ($op == t('Save')))) {
    $form['submit'] = array('#type' => 'submit', '#value' => t('Save'), '#weight' => 19);
  }

  $form['preview'] = array('#type' => 'button', '#value' => t('Preview'), '#weight' => 20);
  $form['#token'] = 'comment'. $edit['nid'] . (isset($edit['pid']) ? $edit['pid'] : '');

  if ($op == t('Preview')) {
    $form['#after_build'] = array('comment_form_add_preview');
  }

  if (empty($edit['cid']) && empty($edit['pid'])) {
    $form['#action'] = url('comment/reply/'. $edit['nid']);
  }

  return $form;
}

/**
 * Theme the comment form box.
 *
 * @param $edit
 *   The form structure.
 * @param $title
 *   The form title.
 */
function comment_form_box($edit, $title = NULL) {
  return theme('box', $title, drupal_get_form('comment_form', $edit, $title));
}

/**
 * Form builder; Generate and validate a comment preview form.
 *
 * @ingroup forms
 */
function comment_form_add_preview($form, &$form_state) {
  global $user;
  $edit = $form_state['values'];
  drupal_set_title(t('Preview comment'));

  $output = '';
  $node = node_load($edit['nid']);

  // Invoke full validation for the form, to protect against cross site
  // request forgeries (CSRF) and setting arbitrary values for fields such as
  // the input format. Preview the comment only when form validation does not
  // set any errors.
  drupal_validate_form($form['form_id']['#value'], $form, $form_state);
  if (!form_get_errors()) {
    _comment_form_submit($edit);
    $comment = (object)$edit;

    // Attach the user and time information.
    if (!empty($edit['author'])) {
      $account = user_load(array('name' => $edit['author']));
    }
    elseif ($user->uid && !isset($edit['is_anonymous'])) {
      $account = $user;
    }
    if (!empty($account)) {
      $comment->uid = $account->uid;
      $comment->name = check_plain($account->name);
    }
    elseif (empty($comment->name)) {
      $comment->name = variable_get('anonymous', t('Anonymous'));
    }
    $comment->timestamp = !empty($edit['timestamp']) ? $edit['timestamp'] : time();
    $output .= theme('comment_view', $comment, $node);
  }
  $form['comment_preview'] = array(
    '#value' => $output,
    '#weight' => -100,
    '#prefix' => '<div class="preview">',
    '#suffix' => '</div>',
  );

  $output = '';

  if ($edit['pid']) {
    $comment = db_fetch_object(db_query('SELECT c.*, u.uid, u.name AS registered_name, u.signature, u.signature_format, u.picture, u.data FROM {comments} c INNER JOIN {users} u ON c.uid = u.uid WHERE c.cid = %d AND c.status = %d', $edit['pid'], COMMENT_PUBLISHED));
    $comment = drupal_unpack($comment);
    $comment->name = $comment->uid ? $comment->registered_name : $comment->name;
    $output .= theme('comment_view', $comment, $node);
  }
  else {
    $suffix = empty($form['#suffix']) ? '' : $form['#suffix'];
    $form['#suffix'] = $suffix . node_view($node);
    $edit['pid'] = 0;
  }

  $form['comment_preview_below'] = array('#value' => $output, '#weight' => 100);

  return $form;
}

/**
 * Validate comment form submissions.
 */
function comment_form_validate($form, &$form_state) {
  global $user;
  if ($user->uid === 0) {
    foreach (array('name', 'homepage', 'mail') as $field) {
      // Set cookie for 365 days.
      if (isset($form_state['values'][$field])) {
        setcookie('comment_info_'. $field, $form_state['values'][$field], time() + 31536000, '/');
      }
    }
  }
  comment_validate($form_state['values']);
}

/**
 * Prepare a comment for submission.
 *
 * @param $comment_values
 *   An associative array containing the comment data.
 */
function _comment_form_submit(&$comment_values) {
  $comment_values += array('subject' => '');
  if (!isset($comment_values['date'])) {
    $comment_values['date'] = 'now';
  }
  $comment_values['timestamp'] = strtotime($comment_values['date']);
  if (isset($comment_values['author'])) {
    $account = user_load(array('name' => $comment_values['author']));
    $comment_values['uid'] = $account->uid;
    $comment_values['name'] = $comment_values['author'];
  }
  // Validate the comment's subject. If not specified, extract
  // one from the comment's body.
  if (trim($comment_values['subject']) == '') {
    // The body may be in any format, so we:
    // 1) Filter it into HTML
    // 2) Strip out all HTML tags
    // 3) Convert entities back to plain-text.
    // Note: format is checked by check_markup().
    $comment_values['subject'] = truncate_utf8(trim(decode_entities(strip_tags(check_markup($comment_values['comment'], $comment_values['format'])))), 29, TRUE);
    // Edge cases where the comment body is populated only by HTML tags will
    // require a default subject.
    if ($comment_values['subject'] == '') {
      $comment_values['subject'] = t('(No subject)');
    }
  }
}

/**
 * Process comment form submissions; prepare the comment, store it, and set a redirection target.
 */
function comment_form_submit($form, &$form_state) {
  _comment_form_submit($form_state['values']);
  if ($cid = comment_save($form_state['values'])) {
    $node = node_load($form_state['values']['nid']);
    // Add 1 to existing $node->comment count to include new comment being added.
    $comment_count = $node->comment_count + 1;
    $page = comment_new_page_count($comment_count, 1, $node);
    $form_state['redirect'] = array('node/'. $node->nid, $page, "comment-$cid");
    return;
  }
}

/**
 * Themes a single comment and related items.
 *
 * @param $comment
 *   The comment object.
 * @param $node
 *   The comment node.
 * @param $links
 *   An associative array containing control links suitable for passing into
 *   theme_links(). These are generated by modules implementing hook_link() with
 *   $type='comment'. Typical examples are links for editing and deleting
 *   comments.
 * @param $visible
 *   Switches between folded/unfolded view. If TRUE the comments are visible, if
 *   FALSE the comments are folded.
 * @ingroup themeable
 */
function theme_comment_view($comment, $node, $links = array(), $visible = TRUE) {
  static $first_new = TRUE;

  $output = '';
  $comment->new = node_mark($comment->nid, $comment->timestamp);
  if ($first_new && $comment->new != MARK_READ) {
    // Assign the anchor only for the first new comment. This avoids duplicate
    // id attributes on a page.
    $first_new = FALSE;
    $output .= "<a id=\"new\"></a>\n";
  }

  $output .= "<a id=\"comment-$comment->cid\"></a>\n";

  // Switch to folded/unfolded view of the comment
  if ($visible) {
    $comment->comment = check_markup($comment->comment, $comment->format, FALSE);

    // Comment API hook
    comment_invoke_comment($comment, 'view');

    $output .= theme('comment', $comment, $node, $links);
  }
  else {
    $output .= theme('comment_folded', $comment);
  }

  return $output;
}


/**
 * Build a comment control form.
 *
 * @param $mode
 *   Comment display mode.
 * @param $order
 *   Comment order mode.
 * @param $comments_per_page
 *   Comments per page.
 * @ingroup forms
 */
function comment_controls(&$form_state, $mode = COMMENT_MODE_THREADED_EXPANDED, $order = COMMENT_ORDER_NEWEST_FIRST, $comments_per_page = 50) {
  $form['mode'] = array('#type' => 'select',
    '#default_value' => $mode,
    '#options' => _comment_get_modes(),
    '#weight' => 1,
  );
  $form['order'] = array(
    '#type' => 'select',
    '#default_value' => $order,
    '#options' => _comment_get_orders(),
    '#weight' => 2,
  );
  foreach (_comment_per_page() as $i) {
    $options[$i] = t('!a comments per page', array('!a' => $i));
  }
  $form['comments_per_page'] = array('#type' => 'select',
    '#default_value' => $comments_per_page,
    '#options' => $options,
    '#weight' => 3,
  );

  $form['submit'] = array('#type' => 'submit',
    '#value' => t('Save settings'),
    '#weight' => 20,
  );

  return $form;
}

/**
 * Theme comment controls box where the user can change the default display mode and display order of comments.
 *
 * @param $form
 *   The form structure.
 * @ingroup themeable
 */
function theme_comment_controls($form) {
  $output = '<div class="container-inline">';
  $output .=  drupal_render($form);
  $output .= '</div>';
  $output .= '<div class="description">'. t('Select your preferred way to display the comments and click "Save settings" to activate your changes.') .'</div>';
  return theme('box', t('Comment viewing options'), $output);
}

/**
 * Process comment_controls form submissions.
 */
function comment_controls_submit($form, &$form_state) {
  global $user;

  $mode = $form_state['values']['mode'];
  $order = $form_state['values']['order'];
  $comments_per_page = $form_state['values']['comments_per_page'];

  if ($user->uid) {
    $account = user_save($user, array('mode' => $mode, 'sort' => $order, 'comments_per_page' => $comments_per_page));
    // Terminate if an error occured during user_save().
    if (!$account) {
      drupal_set_message(t("Error saving user account."), 'error');
      return;
    }
    $user = $account;
  }
  else {
    $_SESSION['comment_mode'] = $mode;
    $_SESSION['comment_sort'] = $order;
    $_SESSION['comment_comments_per_page'] = $comments_per_page;
  }
}

/**
 * Process variables for comment.tpl.php.
 *
 * @see comment.tpl.php
 * @see theme_comment()
 */
function template_preprocess_comment(&$variables) {
  $comment = $variables['comment'];
  $node = $variables['node'];
  $variables['author']    = theme('username', $comment);
  $variables['content']   = $comment->comment;
  $variables['date']      = format_date($comment->timestamp);
  $variables['links']     = isset($variables['links']) ? theme('links', $variables['links']) : '';
  $variables['new']       = $comment->new ? t('new') : '';
  $variables['picture']   = theme_get_setting('toggle_comment_user_picture') ? theme('user_picture', $comment) : '';
  $variables['signature'] = $comment->signature;
  $variables['submitted'] = theme('comment_submitted', $comment);
  $variables['title']     = l($comment->subject, $_GET['q'], array('fragment' => "comment-$comment->cid"));
  $variables['template_files'][] = 'comment-'. $node->type;
  // set status to a string representation of comment->status.
  if (isset($comment->preview)) {
    $variables['status']  = 'comment-preview';
  }
  else {
    $variables['status']  = ($comment->status == COMMENT_NOT_PUBLISHED) ? 'comment-unpublished' : 'comment-published';
  }
}

/**
 * Process variables for comment-folded.tpl.php.
 *
 * @see comment-folded.tpl.php
 * @see theme_comment_folded()
 */
function template_preprocess_comment_folded(&$variables) {
  $comment = $variables['comment'];
  $variables['author'] = theme('username', $comment);
  $variables['date']   = format_date($comment->timestamp);
  $variables['new']    = $comment->new ? t('new') : '';
  $variables['title']  = l($comment->subject, comment_node_url() .'/'. $comment->cid, array('fragment' => "comment-$comment->cid"));
}

/**
 * Theme comment flat collapsed view.
 *
 * @param $comment
 *   The comment to be themed.
 * @param $node
 *   The comment node.
 * @ingroup themeable
 */
function theme_comment_flat_collapsed($comment, $node) {
  return theme('comment_view', $comment, $node, '', 0);
}

/**
 * Theme comment flat expanded view.
 *
 * @param $comment
 *   The comment to be themed.
 * @param $node
 *   The comment node.
 * @ingroup themeable
 */
function theme_comment_flat_expanded($comment, $node) {
  $links = module_invoke_all('link', 'comment', $comment, 0);
  drupal_alter('link', $links, $node, $comment);
  return theme('comment_view', $comment, $node, $links);
}

/**
 * Theme comment thread collapsed view.
 *
 * @param $comment
 *   The comment to be themed.
 * @param $node
 *   The comment node.
 * @ingroup themeable
 */
function theme_comment_thread_collapsed($comment, $node) {
  return theme('comment_view', $comment, $node, '', 0);
}

/**
 * Theme comment thread expanded view.
 *
 * @param $comment
 *   The comment to be themed.
 * @param $node
 *   The comment node.
 * @ingroup themeable
 */
function theme_comment_thread_expanded($comment, $node) {
  $links = module_invoke_all('link', 'comment', $comment, 0);
  drupal_alter('link', $links, $node, $comment);
  return theme('comment_view', $comment, $node, $links);
}

/**
 * Theme a "you can't post comments" notice.
 *
 * @param $node
 *   The comment node.
 * @ingroup themeable
 */
function theme_comment_post_forbidden($node) {
  global $user;
  static $authenticated_post_comments;

  if (!$user->uid) {
    if (!isset($authenticated_post_comments)) {
      // We only output any link if we are certain, that users get permission
      // to post comments by logging in. We also locally cache this information.
      $authenticated_post_comments = array_key_exists(DRUPAL_AUTHENTICATED_RID, user_roles(TRUE, 'post comments') + user_roles(TRUE, 'post comments without approval'));
    }

    if ($authenticated_post_comments) {
      // We cannot use drupal_get_destination() because these links
      // sometimes appear on /node and taxonomy listing pages.
      if (variable_get('comment_form_location_'. $node->type, COMMENT_FORM_SEPARATE_PAGE) == COMMENT_FORM_SEPARATE_PAGE) {
        $destination = 'destination='. rawurlencode("comment/reply/$node->nid#comment-form");
      }
      else {
        $destination = 'destination='. rawurlencode("node/$node->nid#comment-form");
      }

      if (variable_get('user_register', 1)) {
        // Users can register themselves.
        return t('<a href="@login">Login</a> or <a href="@register">register</a> to post comments', array('@login' => url('user/login', array('query' => $destination)), '@register' => url('user/register', array('query' => $destination))));
      }
      else {
        // Only admins can add new users, no public registration.
        return t('<a href="@login">Login</a> to post comments', array('@login' => url('user/login', array('query' => $destination))));
      }
    }
  }
}

/**
 * Process variables for comment-wrapper.tpl.php.
 *
 * @see comment-wrapper.tpl.php
 */
function template_preprocess_comment_wrapper(&$variables) {
  // Provide contextual information.
  $variables['display_mode']  = _comment_get_display_setting('mode', $variables['node']);
  $variables['display_order'] = _comment_get_display_setting('sort', $variables['node']);
  $variables['comment_controls_state'] = variable_get('comment_controls_'. $variables['node']->type, COMMENT_CONTROLS_HIDDEN);
  $variables['template_files'][] = 'comment-wrapper-'. $variables['node']->type;
}

/**
 * Theme a "Submitted by ..." notice.
 *
 * @param $comment
 *   The comment.
 * @ingroup themeable
 */
function theme_comment_submitted($comment) {
  return t('Submitted by !username on @datetime.',
    array(
      '!username' => theme('username', $comment),
      '@datetime' => format_date($comment->timestamp)
    ));
}

/**
 * Return an array of viewing modes for comment listings.
 *
 * We can't use a global variable array because the locale system
 * is not initialized yet when the comment module is loaded.
 */
function _comment_get_modes() {
  return array(
    COMMENT_MODE_FLAT_COLLAPSED => t('Flat list - collapsed'),
    COMMENT_MODE_FLAT_EXPANDED => t('Flat list - expanded'),
    COMMENT_MODE_THREADED_COLLAPSED => t('Threaded list - collapsed'),
    COMMENT_MODE_THREADED_EXPANDED => t('Threaded list - expanded')
  );
}

/**
 * Return an array of viewing orders for comment listings.
 *
 * We can't use a global variable array because the locale system
 * is not initialized yet when the comment module is loaded.
 */
function _comment_get_orders() {
  return array(
    COMMENT_ORDER_NEWEST_FIRST => t('Date - newest first'),
    COMMENT_ORDER_OLDEST_FIRST => t('Date - oldest first')
  );
}

/**
 * Return an array of "comments per page" settings from which the user
 * can choose.
 */
function _comment_per_page() {
  return drupal_map_assoc(array(10, 30, 50, 70, 90, 150, 200, 250, 300));
}

/**
 * Return a current comment display setting
 *
 * @param $setting
 *   can be one of these: 'mode', 'sort', 'comments_per_page'
 * @param $node
 *   The comment node in question.
 */
function _comment_get_display_setting($setting, $node) {
  global $user;

  if (isset($_GET[$setting])) {
    $value = $_GET[$setting];
  }
  else {
    // get the setting's site default
    switch ($setting) {
      case 'mode':
        $default = variable_get('comment_default_mode_'. $node->type, COMMENT_MODE_THREADED_EXPANDED);
        break;
      case 'sort':
        $default = variable_get('comment_default_order_'. $node->type, COMMENT_ORDER_NEWEST_FIRST);
        break;
      case 'comments_per_page':
        $default = variable_get('comment_default_per_page_'. $node->type, 50);
    }
    if (variable_get('comment_controls_'. $node->type, COMMENT_CONTROLS_HIDDEN) == COMMENT_CONTROLS_HIDDEN) {
      // if comment controls are disabled use site default
      $value = $default;
    }
    else {
      // otherwise use the user's setting if set
      if (isset($user->$setting) && $user->$setting) {
        $value = $user->$setting;
      }
      else if (isset($_SESSION['comment_'. $setting]) && $_SESSION['comment_'. $setting]) {
        $value = $_SESSION['comment_'. $setting];
      }
      else {
        $value = $default;
      }
    }
  }
  return $value;
}

/**
 * Updates the comment statistics for a given node. This should be called any
 * time a comment is added, deleted, or updated.
 *
 * The following fields are contained in the node_comment_statistics table.
 * - last_comment_timestamp: the timestamp of the last comment for this node or the node create stamp if no comments exist for the node.
 * - last_comment_name: the name of the anonymous poster for the last comment
 * - last_comment_uid: the uid of the poster for the last comment for this node or the node authors uid if no comments exists for the node.
 * - comment_count: the total number of approved/published comments on this node.
 */
function _comment_update_node_statistics($nid) {
  $count = db_result(db_query('SELECT COUNT(cid) FROM {comments} WHERE nid = %d AND status = %d', $nid, COMMENT_PUBLISHED));

  // comments exist
  if ($count > 0) {
    $last_reply = db_fetch_object(db_query_range('SELECT cid, name, timestamp, uid FROM {comments} WHERE nid = %d AND status = %d ORDER BY cid DESC', $nid, COMMENT_PUBLISHED, 0, 1));
    db_query("UPDATE {node_comment_statistics} SET comment_count = %d, last_comment_timestamp = %d, last_comment_name = '%s', last_comment_uid = %d WHERE nid = %d", $count, $last_reply->timestamp, $last_reply->uid ? '' : $last_reply->name, $last_reply->uid, $nid);
  }

  // no comments
  else {
    $node = db_fetch_object(db_query("SELECT uid, created FROM {node} WHERE nid = %d", $nid));
    db_query("UPDATE {node_comment_statistics} SET comment_count = 0, last_comment_timestamp = %d, last_comment_name = '', last_comment_uid = %d WHERE nid = %d", $node->created, $node->uid, $nid);
  }
}

/**
 * Invoke a hook_comment() operation in all modules.
 *
 * @param &$comment
 *   A comment object.
 * @param $op
 *   A string containing the name of the comment operation.
 * @return
 *   The returned value of the invoked hooks.
 */
function comment_invoke_comment(&$comment, $op) {
  $return = array();
  foreach (module_implements('comment') as $name) {
    $function = $name .'_comment';
    $result = $function($comment, $op);
    if (isset($result) && is_array($result)) {
      $return = array_merge($return, $result);
    }
    else if (isset($result)) {
      $return[] = $result;
    }
  }
  return $return;
}

/**
 * Generate vancode.
 *
 * Consists of a leading character indicating length, followed by N digits
 * with a numerical value in base 36. Vancodes can be sorted as strings
 * without messing up numerical order.
 *
 * It goes:
 * 00, 01, 02, ..., 0y, 0z,
 * 110, 111, ... , 1zy, 1zz,
 * 2100, 2101, ..., 2zzy, 2zzz,
 * 31000, 31001, ...
 */
function int2vancode($i = 0) {
  $num = base_convert((int)$i, 10, 36);
  $length = strlen($num);
  return chr($length + ord('0') - 1) . $num;
}

/**
 * Decode vancode back to an integer.
 */
function vancode2int($c = '00') {
  return base_convert(substr($c, 1), 36, 10);
}

/**
 * Implementation of hook_hook_info().
 */
function comment_hook_info() {
  return array(
    'comment' => array(
      'comment' => array(
        'insert' => array(
          'runs when' => t('After saving a new comment'),
        ),
        'update' => array(
          'runs when' => t('After saving an updated comment'),
        ),
        'delete' => array(
          'runs when' => t('After deleting a comment')
        ),
        'view' => array(
          'runs when' => t('When a comment is being viewed by an authenticated user')
        ),
      ),
    ),
  );
}

/**
 * Implementation of hook_action_info().
 */
function comment_action_info() {
  return array(
    'comment_publish_action' => array(
      'description' => t('Publish comment'),
      'type' => 'comment',
      'configurable' => FALSE,
      'hooks' => array(
        'comment' => array('insert', 'update'),
      ),
    ),
    'comment_unpublish_action' => array(
      'description' => t('Unpublish comment'),
      'type' => 'comment',
      'configurable' => FALSE,
      'hooks' => array(
        'comment' => array('insert', 'update'),
      )
    ),
    'comment_unpublish_by_keyword_action' => array(
      'description' => t('Unpublish comment containing keyword(s)'),
      'type' => 'comment',
      'configurable' => TRUE,
      'hooks' => array(
        'comment' => array('insert', 'update'),
      )
    )
  );
}

/**
 * Action to publish a comment.
 *
 * @param $comment
 *   An optional comment object.
 * @param $context
 *   Keyed array. Must contain the id of the comment if $comment is not passed.
 *
 * @ingroup actions
 */
function comment_publish_action($comment, $context = array()) {
  if (isset($comment->cid)) {
    $cid = $comment->cid;
    $subject = $comment->subject;
  }
  else {
    $cid = $context['cid'];
    $subject = db_result(db_query("SELECT subject FROM {comments} WHERE cid = %d", $cid));
  }
  db_query('UPDATE {comments} SET status = %d WHERE cid = %d', COMMENT_PUBLISHED, $cid);
  watchdog('action', 'Published comment %subject.', array('%subject' => $subject));
}

/**
 * Action to unpublish a comment.
 *
 * @param $comment
 *   An optional comment object.
 * @param $context
 *   Keyed array. Must contain the id of the comment if $comment is not passed.
 *
 * @ingroup actions
 */
function comment_unpublish_action($comment, $context = array()) {
  if (isset($comment->cid)) {
    $cid = $comment->cid;
    $subject = $comment->subject;
  }
  else {
    $cid = $context['cid'];
    $subject = db_result(db_query("SELECT subject FROM {comments} WHERE cid = %d", $cid));
  }
  db_query('UPDATE {comments} SET status = %d WHERE cid = %d', COMMENT_NOT_PUBLISHED, $cid);
  watchdog('action', 'Unpublished comment %subject.', array('%subject' => $subject));
}

/**
 * Action to unpublish a comment if it contains a certain string.
 *
 * @param $comment
 *   A comment object.
 * @param $context
 *   An array providing more information about the context of the call to this action.
 *   Unused here, since this action currently only supports the insert and update ops of
 *   the comment hook, both of which provide a complete $comment object.
 *
 * @ingroup actions
 * @see comment_unpublish_by_keyword_action_form()
 * @see comment_unpublish_by_keyword_action_submit()
 */
function comment_unpublish_by_keyword_action($comment, $context) {
  foreach ($context['keywords'] as $keyword) {
    if (strpos($comment->comment, $keyword) !== FALSE || strpos($comment->subject, $keyword) !== FALSE) {
      db_query('UPDATE {comments} SET status = %d WHERE cid = %d', COMMENT_NOT_PUBLISHED, $comment->cid);
      watchdog('action', 'Unpublished comment %subject.', array('%subject' => $comment->subject));
      break;
    }
  }
}

/**
 * Form builder; Prepare a form for blacklisted keywords.
 *
 * @ingroup forms
 * @see comment_unpublish_by_keyword_action()
 * @see comment_unpublish_by_keyword_action_submit()
 */
function comment_unpublish_by_keyword_action_form($context) {
  $form['keywords'] = array(
    '#title' => t('Keywords'),
    '#type' => 'textarea',
    '#description' => t('The comment will be unpublished if it contains any of the character sequences above. Use a comma-separated list of character sequences. Example: funny, bungee jumping, "Company, Inc.". Character sequences are case-sensitive.'),
    '#default_value' => isset($context['keywords']) ? drupal_implode_tags($context['keywords']) : '',
  );
  return $form;
}

/**
 * Process comment_unpublish_by_keyword_action_form form submissions.
 *
 * @see comment_unpublish_by_keyword_action()
 */
function comment_unpublish_by_keyword_action_submit($form, $form_state) {
  return array('keywords' => drupal_explode_tags($form_state['values']['keywords']));
}
